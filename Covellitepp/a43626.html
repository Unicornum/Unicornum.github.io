<!-- HTML header for doxygen 1.8.15-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-151583584-1"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag() { dataLayer.push(arguments); }
        gtag('js', new Date());
        gtag('config', 'UA-151583584-1');
    </script>
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=9" />
    <meta name="generator" content="Doxygen 1.8.18" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Covellite++: Отрисовка 2D объектов</title>
    <link href="tabs.css" rel="stylesheet" type="text/css" />
    <script type="text/javascript" src="jquery.js"></script>
    <script type="text/javascript" src="dynsections.js"></script>
    <link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
    <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
    <link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="Title.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Covellite++
   &#160;<span id="projectnumber">Version: 2.3.0 Revision: 2580 Platform: x64 Build: 15:23 16.10.2020</span>
   </div>
   <div id="projectbrief">Кроссплатформенный фреймворк для разработки приложений на С++</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Создано системой Doxygen 1.8.18 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Поиск');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Поиск');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('a43626.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Отрисовка 2D объектов </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Описание отрисовки в окне программы плоских объектов с использованием <a class="el" href="a43638.html">компонентной системы</a>.</p>
<h1>Используемые термины </h1>
<ul>
<li><b>Компонент</b> - объект, содержащий информацию об одном аспекте игрового объекта (таких как текстура, меш, положение и т.п.).</li>
</ul>
<p><b>Игровой</b> <b>объект</b> - объект в игровом мире, содержащий информацию в виде набора компонентов.</p><ul>
<li><b>Игровой</b> <b>мир</b> - набор игровых объектов, разбитый на иерархическую структуру из ячеек, каждая из которых содержит несколько игровых объектов; назначение - оптимизация подгрузки и выгрузки игровых объектов (сразу ячейками).</li>
<li><b>Игровая</b> <b>сцена</b> - набор игровых объектов, непосредственно участвующих в игровом процессе; объекты подгружаются (по мере необходимости) из игрового мира и это именно те объекты, которые должны обновляться в процессе игры.</li>
<li><b>Рендер</b> - объект, предназначенный для отображения игровых объектов в 3D сцене, создается на основе одного или нескольких компонентов.</li>
<li><b>Объект</b> <b>3D</b> <b>сцены</b> - объект (набор рендеров), из которых состоит 3D сцена.</li>
<li><b>3D</b> <b>сцена</b> - набор объектов 3D сцены, которые отображаются в окне программы; является 'зеркалом' той части объектов игровой сцены, которые попадают в поле зрения камеры.</li>
</ul>
<dl class="section note"><dt>Заметки</dt><dd><ul>
<li>В данном описании под <b>объектом</b> подразумевается 'объект 3D сцены', а под <b>сценой</b> - '3D сцена'.</li>
<li>Обозначение компонента как State.Scissor подразумевает объект компонента, у которого установлены параметры type == 'State' и kind == 'Scissor'.</li>
<li>Под <b>объектом</b> <b>компонента</b> подразумевается объект C++ класса компонента.</li>
</ul>
Подробнее о компонентах и их параметрах см. <a class="el" href="a43638.html">Компонентная система</a>.</dd></dl>
<h1>Общее описание </h1>
<p>Хотя <a class="el" href="a43638.html">компонентная система</a> предназначена - в первую очередь - для отрисовки трехмерных сцен, тем не менее она позволяет также рисовать в окне простые плоские объекты (именно этот режим используется для отрисовки GUI). Идея состоит в том, что при помощи специальной ортогональной камеры (которая 'смотрит' на плоскость Oxy со стороны положительных значений оси z) отображаются объекты, состоящие из треугольников, вершины которых лежат в плоскости Oxy.</p>
<p>Используемый формат вершин:</p>
<div class="fragment"><div class="line">  <span class="keyword">using</span> Vertex_t = <a class="code" href="a42360.html">::covellite::api::Vertex</a>;</div>
</div><!-- fragment --><p> Отрисовка производится при помощи формирования <b>сцены</b>, содержащей рендеры:</p><ul>
<li><b>Камеры</b> - уникальный объект, определяющий способ отрисовки сцены.</li>
<li><b>Общих</b> <b>объектов</b> (например, настройки конвеера рендеринга).</li>
<li><b>Объектов</b>, которые непосредственно формируют требуемое изображение на экране.</li>
</ul>
<div class="image">
<img src="Gui.2D.Components.png" alt=""/>
</div>
<p>Сцена определяется набором идентификаторов ее объектов, таких сцен может быть несколько, добавлять объекты разных сцен можно в очереди рендеринга разных проходов, при рендеринге нескольких сцен текущая сцена будет отрисоваваться поверх предыдущей; также можно сформировать несколько наборов идентификаторов объектов, каждый из которых отрисовывать в зависимости от неких условий.</p>
<p>Создание и удаление рендеров для компонентов, а также рендеринг объектов 3D сцены производится через объект класса <a class="el" href="a42736.html" title="Класс входит в проект Covellite.Expanse   Класс окна, предоставлющего клиентскому коду возможности пр...">covellite::expanse::Window</a>, который должен быть создан при старте программы и передан окну формирования 3D сцены.</p>
<dl class="section warning"><dt>Предупреждения</dt><dd>Реализация OpenGL требует, чтобы рендеры создавались и активировались в том же потоке, в котором было создано окно графического Api.</dd></dl>
<dl class="section note"><dt>Заметки</dt><dd>При использовании в разных <b>объектах</b> <b>компонентов</b> с одним и тем же <b>id</b> будет использоваться один и тот же объект рендера (это позволяет, например, один раз сформировать набор общих для всех объектов рендеров, а затем обращаться к ним через <b>объекты</b> <b>компонентов</b>, содержащих только идентификаторы), но при этом следует учитывать, что для некоторых типов компонентов рендеры не создаются (например, компоненты Data). Для таких компонентов параметр <b>id</b> не имеет смысла и при необходимости использования несколькими объектами одного и того же компонента (например, для совместного перемещения группы объектов), следует использовать один и тот же <b>объект</b> <b>компонента</b>.</dd></dl>
<p>Разные объекты могут использовать рендеры, выполняющие одно и то же действие, в этом случае для экономии ресурсов можно создать эти рендеры (один раз) заранее, а в дальнейшем использовать их через компоненты с соответствующими id.</p>
<p>Пример создания объекта, состоящего из компонентов, которые в дальнейшем будут использоваться для всех объектов:</p><ul>
<li>Двух тестур.</li>
<li>Двух пиксельных шейдеров (для для отрисовки текстурированного и залитого цветом объектов).</li>
<li>Индексного буфера.</li>
<li>Updater'a, синхронизирующего fps = 60.</li>
<li>Главного updater'a сцены, который добавляет идентификаторы объектов, которые должны отрисовываться в текущем кадре.</li>
</ul>
<div class="fragment"><div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> &amp; Vfs = ::covellite::app::Vfs_t::GetInstance();</div>
<div class="line">        </div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> CommonObjectId = CreateObject(</div>
<div class="line">    LoadTexture(<span class="stringliteral">&quot;simple2dgame.bricks.jpg&quot;</span>, uT(<span class="stringliteral">&quot;Simple2DGame.Texture&quot;</span>)) +</div>
<div class="line">    LoadTexture(<span class="stringliteral">&quot;simple2dgame.clock.png&quot;</span>, uT(<span class="stringliteral">&quot;Simple2DGame.Texture.Clock&quot;</span>)) +</div>
<div class="line">    GameObject_t</div>
<div class="line">    {</div>
<div class="line">      Component_t::Make(</div>
<div class="line">      {</div>
<div class="line">        { uT(<span class="stringliteral">&quot;id&quot;</span>), uT(<span class="stringliteral">&quot;Simple2DGame.Shader.Pixel.Textured&quot;</span>) },</div>
<div class="line">        { uT(<span class="stringliteral">&quot;type&quot;</span>), uT(<span class="stringliteral">&quot;Shader&quot;</span>) },</div>
<div class="line">        { uT(<span class="stringliteral">&quot;entry&quot;</span>), uT(<span class="stringliteral">&quot;psTextured&quot;</span>) },</div>
<div class="line">        { uT(<span class="stringliteral">&quot;content&quot;</span>), Vfs.GetData(<span class="stringliteral">&quot;Data\\Shaders\\Textured.fx&quot;</span>) },</div>
<div class="line">      }),</div>
<div class="line">      Component_t::Make(</div>
<div class="line">      {</div>
<div class="line">        { uT(<span class="stringliteral">&quot;id&quot;</span>), uT(<span class="stringliteral">&quot;Simple2DGame.Shader.Pixel.Colored&quot;</span>) },</div>
<div class="line">        { uT(<span class="stringliteral">&quot;type&quot;</span>), uT(<span class="stringliteral">&quot;Shader&quot;</span>) },</div>
<div class="line">        { uT(<span class="stringliteral">&quot;entry&quot;</span>), uT(<span class="stringliteral">&quot;psColored&quot;</span>) },</div>
<div class="line">        <span class="comment">// { uT(&quot;content&quot;), - }, // использовать шейдер по умолчанию</span></div>
<div class="line">      }),</div>
<div class="line">      Component_t::Make(</div>
<div class="line">      {</div>
<div class="line">        { uT(<span class="stringliteral">&quot;id&quot;</span>), uT(<span class="stringliteral">&quot;Simple2DGame.Present.Rectangle&quot;</span>) },</div>
<div class="line">        { uT(<span class="stringliteral">&quot;type&quot;</span>), uT(<span class="stringliteral">&quot;Present&quot;</span>) },</div>
<div class="line">        { uT(<span class="stringliteral">&quot;content&quot;</span>), ::std::vector&lt;int&gt;{ 0,  1,  2,   2,  1,  3, } },</div>
<div class="line">      }),</div>
<div class="line">      pSynchronizer60fps,</div>
<div class="line">      pMainUpdater</div>
<div class="line">    });</div>
</div><!-- fragment --> <dl class="section note"><dt>Заметки</dt><dd>Далее в примерах в качестве объектов будут использоваться прямоугольники, состоящие из двух треугольников, но на практике объекты могут быть любой формы из любого количества треугольников (ограничением являются лишь возможности железа).</dd></dl>
<h2>Камера и настройки конвеера рендеринга </h2>
<dl class="section note"><dt>Заметки</dt><dd>Здесь и далее все создаваемые игровые объекты создаются через функцию класса <a class="el" href="a42736.html" title="Класс входит в проект Covellite.Expanse   Класс окна, предоставлющего клиентскому коду возможности пр...">covellite::expanse::Window</a>, а возвращаемые ей идентификаторы добавляются в очередь рендеринга главным updater'ом сцены.</dd></dl>
<p>В данном примере формируется объект, состоящий из компонентов:</p><ul>
<li>Ортографической камеры (с компонентом смещения ее таким образом, чтобы центр поля зрения оказался в центре экрана).</li>
<li>Компонента, включающего использование прозрачности.</li>
<li>Компонента настроек вывода текстуры.</li>
<li>Компонента используемого вертексного шейдера:</li>
</ul>
<div class="fragment"><div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> pCameraPosition = Component_t::Make(</div>
<div class="line">    {</div>
<div class="line">      { uT(<span class="stringliteral">&quot;type&quot;</span>), uT(<span class="stringliteral">&quot;Data&quot;</span>) },</div>
<div class="line">      { uT(<span class="stringliteral">&quot;kind&quot;</span>), uT(<span class="stringliteral">&quot;Position&quot;</span>) },</div>
<div class="line">      { uT(<span class="stringliteral">&quot;x&quot;</span>), -_Xo },</div>
<div class="line">      { uT(<span class="stringliteral">&quot;y&quot;</span>), -_Yo },</div>
<div class="line">    });</div>
<div class="line">    </div>
<div class="line">  <span class="keywordflow">return</span> CreateObject(</div>
<div class="line">    {</div>
<div class="line">      Component_t::Make(</div>
<div class="line">      {</div>
<div class="line">        { uT(<span class="stringliteral">&quot;id&quot;</span>), uT(<span class="stringliteral">&quot;Simple2DGame.Camera.&quot;</span>) + Id.GetStringId() },</div>
<div class="line">        { uT(<span class="stringliteral">&quot;type&quot;</span>), uT(<span class="stringliteral">&quot;Camera&quot;</span>) },</div>
<div class="line">        { uT(<span class="stringliteral">&quot;kind&quot;</span>), uT(<span class="stringliteral">&quot;Orthographic&quot;</span>) },</div>
<div class="line">        { uT(<span class="stringliteral">&quot;service&quot;</span>), GameObject_t{ pCameraPosition } },</div>
<div class="line">      }),</div>
<div class="line">      Component_t::Make(</div>
<div class="line">      {</div>
<div class="line">        { uT(<span class="stringliteral">&quot;id&quot;</span>), uT(<span class="stringliteral">&quot;Simple2DGame.State.Blend&quot;</span>) },</div>
<div class="line">        { uT(<span class="stringliteral">&quot;type&quot;</span>), uT(<span class="stringliteral">&quot;State&quot;</span>) },</div>
<div class="line">        { uT(<span class="stringliteral">&quot;kind&quot;</span>), uT(<span class="stringliteral">&quot;Blend&quot;</span>) },</div>
<div class="line">      }),</div>
<div class="line">      Component_t::Make(</div>
<div class="line">      {</div>
<div class="line">        { uT(<span class="stringliteral">&quot;id&quot;</span>), uT(<span class="stringliteral">&quot;Simple2DGame.State.Sampler&quot;</span>) },</div>
<div class="line">        { uT(<span class="stringliteral">&quot;type&quot;</span>), uT(<span class="stringliteral">&quot;State&quot;</span>) },</div>
<div class="line">        { uT(<span class="stringliteral">&quot;kind&quot;</span>), uT(<span class="stringliteral">&quot;Sampler&quot;</span>) },</div>
<div class="line">      }),</div>
<div class="line">      Component_t::Make(</div>
<div class="line">      {</div>
<div class="line">        { uT(<span class="stringliteral">&quot;id&quot;</span>), uT(<span class="stringliteral">&quot;Simple2DGame.Shader.Vertex.Rectangle&quot;</span>) },</div>
<div class="line">        { uT(<span class="stringliteral">&quot;type&quot;</span>), uT(<span class="stringliteral">&quot;Shader&quot;</span>) },</div>
<div class="line">        { uT(<span class="stringliteral">&quot;entry&quot;</span>), uT(<span class="stringliteral">&quot;vsFlat&quot;</span>) },</div>
<div class="line">      }),</div>
<div class="line">    });</div>
</div><!-- fragment --><p> Если камера не использует буфер глубины, отрисовка объектов производится в порядке вызовов их рендеров (те, что вызваны позже будут отрисованы поверх тех, которые были вызваны ранее), при включенном буфере глубины видимость объектов будет определяться их расположением на оси z (подробнее про положение объектов см. в описании рендеринга объектов).</p>
<dl class="section note"><dt>Заметки</dt><dd>При использовании буфера глубины следует учитывать, что отрисовываться будут только те объекты, которые находятся вдоль оси z в диапазоне координат [-1.0f...1.0f], с учетом установленного компонента масштабирования (если, например, параметр z у Data.Scale будет установлен в 0.0f, то независимо от положения на оси z все объекты будут отрисовываться в порядке вызовов их рендеров).</dd></dl>
<h2>Рендеринг объектов </h2>
<p>Объект, отображаемый на экране, представляет собой набор рендеров, который создается на основе набора компонентов и должен включать:</p><ul>
<li>Вершинный шейдер.</li>
<li>Пиксельный шейдер.</li>
<li>Текстуру (только для текстурированных объектов).</li>
<li>Вертексный буфер.</li>
<li>Компонент трансформации (не обязателен).</li>
<li>Present с индексным буфером (именно он осуществляет отрисовку объекта, поэтому должен располагаться последним).</li>
</ul>
<p>Вертексный буфер формируется в зависимости от того, какой объект (просто закрашенный цветом или текстурированный) нужно отрисовывать.</p>
<p>Компоненты Data.Position/Data.Rotation/Data.Scale используются для перемещения/вращения/изменения размеров объектов без их пересоздания (достаточно установить новые значения параметров при обновлении сцены), причем:</p><ul>
<li>Компонентов одного типа может быть несколько (что позволяет, например, создавать группы объектов, которые должны быть расположены относительно друг друга определенным образом, но при этом двигаться/вращаться вместе; во втором случае необходимо использовать общий <b>объект</b> <b>компонента</b>, использование разных объектов с одинаковым <b>id</b> нужного эффекта не даст).</li>
<li>Важен порядок следования компонентов (поворот-перемещение даст сначала поворот вокруг точки [0, 0] с нулевым радиусом, а затем уже смещение повернутого объекта, а перемещение-поворот даст сначала смещение от точки [0, 0], а затем уже поворот вокруг нее с радиусом смещения).</li>
</ul>
<dl class="todo"><dt><b><a class="el" href="a41942.html#_todo000001">Необходимо сделать:</a></b></dt><dd><ul>
<li>Добавить картинку, объясняющую разницу между поворот-смещение и смещение-поворот.</li>
</ul>
</dd></dl>
<p>Поскольку одному пикселю на экране соответствует смещение на 1.0f вдоль осей X и Y, существует два способа создания объектов требуемого размера:</p><ul>
<li>Сформировать вертексный буфер, содержащий координаты вершин в пикселях.</li>
<li>Сформировать вертексный буфер, содержащий координаты вершин в условных единицах (например, считать <b>единицей</b> ширину окна программы) и каждому объекту добавить компонент Data.Scale, которому установлены параметры <b>x</b> и <b>y</b>, увеличивающие координаты до нужных значений в пикселях.</li>
</ul>
<h3>Простой объект</h3>
<p>Пример формирования простого залитого заданным цветом объекта; по порядку:</p><ul>
<li>Пиксельный шейдер для отрисовки объектов без текстуры (создан ранее, поэтому используется компонент, содержащий только id).</li>
<li>Вертексный буфер, содержащий уникальные для данного объекта данные вершин.</li>
<li>Уникальный компонент локальной транформации объекта, включающий:<ul>
<li>Смещение объектов относительно начала координат.</li>
<li>Масштабирования до размеров экрана (за единицу принят размер центральной области игры)).</li>
</ul>
</li>
<li>Компонент отрисовки объекта (создан ранее).</li>
</ul>
<div class="fragment"><div class="line">  <span class="keyword">const</span> VertexData_t VertexData =</div>
<div class="line">  {</div>
<div class="line">    {  </div>
<div class="line">      _Polygon.Left, _Polygon.Top, 0.0f, 1.0f,</div>
<div class="line">      _TexCoord.Left, _TexCoord.Top,</div>
<div class="line">      _R, _G, _B, _A,</div>
<div class="line">    }, <span class="comment">// 0</span></div>
<div class="line">    {  </div>
<div class="line">      _Polygon.Left, _Polygon.Bottom, 0.0f, 1.0f,</div>
<div class="line">      _TexCoord.Left, _TexCoord.Bottom,</div>
<div class="line">      _R, _G, _B, _A,</div>
<div class="line">    }, <span class="comment">// 1</span></div>
<div class="line">    {  </div>
<div class="line">      _Polygon.Right, _Polygon.Top, 0.0f, 1.0f,</div>
<div class="line">      _TexCoord.Right, _TexCoord.Top,</div>
<div class="line">      _R, _G, _B, _A,</div>
<div class="line">    }, <span class="comment">// 2</span></div>
<div class="line">    {  </div>
<div class="line">      _Polygon.Right, _Polygon.Bottom, 0.0f, 1.0f,</div>
<div class="line">      _TexCoord.Right, _TexCoord.Bottom,</div>
<div class="line">      _R, _G, _B, _A,</div>
<div class="line">    }, <span class="comment">// 3</span></div>
<div class="line">  };</div>
</div><!-- fragment --><div class="fragment"><div class="line">      Component_t::Make(</div>
<div class="line">      {</div>
<div class="line">        { uT(<span class="stringliteral">&quot;id&quot;</span>), uT(<span class="stringliteral">&quot;Simple2DGame.Shader.Pixel.Colored&quot;</span>) },</div>
<div class="line">      }),</div>
</div><!-- fragment --><div class="fragment"><div class="line">      Component_t::Make(</div>
<div class="line">      {</div>
<div class="line">        { uT(<span class="stringliteral">&quot;id&quot;</span>), uT(<span class="stringliteral">&quot;Simple2DGame.Buffer.Vertex.&quot;</span>) + Id.GetStringId() },</div>
<div class="line">        { uT(<span class="stringliteral">&quot;type&quot;</span>), uT(<span class="stringliteral">&quot;Buffer&quot;</span>) },</div>
<div class="line">        { uT(<span class="stringliteral">&quot;content&quot;</span>), VertexData },</div>
<div class="line">        { uT(<span class="stringliteral">&quot;dimension&quot;</span>), 2 },</div>
<div class="line">      }),</div>
<div class="line">      Component_t::Make(</div>
<div class="line">      {</div>
<div class="line">        { uT(<span class="stringliteral">&quot;id&quot;</span>), uT(<span class="stringliteral">&quot;Simple2DGame.Transform.Rectangle.&quot;</span>) + Id.GetStringId() },</div>
<div class="line">        { uT(<span class="stringliteral">&quot;type&quot;</span>), uT(<span class="stringliteral">&quot;Transform&quot;</span>) },</div>
<div class="line">        { uT(<span class="stringliteral">&quot;service&quot;</span>), Trasform },</div>
<div class="line">      }),</div>
<div class="line">      Component_t::Make(</div>
<div class="line">      {</div>
<div class="line">        { uT(<span class="stringliteral">&quot;id&quot;</span>), uT(<span class="stringliteral">&quot;Simple2DGame.Present.Rectangle&quot;</span>) },</div>
<div class="line">      })</div>
</div><!-- fragment --> <dl class="section note"><dt>Заметки</dt><dd><ul>
<li>Общий для всех объектов вертексный шейдер устанавливается вместе с камерой.</li>
<li>Цвета разных вершин могут отличаться, что позволяет использовать градиентную заливку цветом.</li>
<li>Текстурные координаты для такого объекта не имеют смысла и будут проигнорированы.</li>
</ul>
</dd></dl>
<h3>Текстурированный объект</h3>
<p>Текстуры, которые будут использоваться, можно подгрузить заранее, чтобы потом ссылаться на них по их идентификатору.</p>
<div class="fragment"><div class="line">  <span class="keyword">const</span> image::Universal_t&lt;image::pixel::RGBA&gt; Image</div>
<div class="line">  {</div>
<div class="line">    ::covellite::app::Vfs_t::GetInstance().GetData(</div>
<div class="line">      PathToTextureDirectory / _RelativePathToSourceFile)</div>
<div class="line">  };</div>
<div class="line"> </div>
<div class="line">  (*_pData)[uT(<span class="stringliteral">&quot;content&quot;</span>)] = Image.GetData().Buffer;</div>
<div class="line">  (*_pData)[uT(<span class="stringliteral">&quot;width&quot;</span>)]  = <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(Image.GetData().Width);</div>
<div class="line">  (*_pData)[uT(<span class="stringliteral">&quot;height&quot;</span>)] = <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(Image.GetData().Height);</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span></div>
<div class="line">  {</div>
<div class="line">    Component_t::Make(</div>
<div class="line">    {</div>
<div class="line">      { uT(<span class="stringliteral">&quot;id&quot;</span>), _Id },</div>
<div class="line">      { uT(<span class="stringliteral">&quot;type&quot;</span>), uT(<span class="stringliteral">&quot;Texture&quot;</span>) },</div>
<div class="line">      { uT(<span class="stringliteral">&quot;service&quot;</span>), GameObject_t{ _pData } },</div>
<div class="line">    }),</div>
<div class="line">  };</div>
<div class="line"> </div>
</div><!-- fragment --><p> Пример формирования текстурированного объекта; по порядку:</p><ul>
<li>Пиксельный шейдер для отрисовки объектов c текстурой (создан ранее, поэтому используется компонент, содержащий только id).</li>
<li>Текстура (создана ранее).</li>
<li>Вертексный буфер, содержащий уникальные для данного объекта данные вершин.</li>
<li>Уникальный компонент локальной транформации объекта, включающий:<ul>
<li>Смещение объектов относительно начала координат.</li>
<li>Масштабирования до размеров экрана (за единицу принят размер центральной области игры)).</li>
</ul>
</li>
<li>Компонент отрисовки объекта (создан ранее).</li>
</ul>
<div class="fragment"><div class="line">  <span class="keyword">const</span> VertexData_t VertexData =</div>
<div class="line">  {</div>
<div class="line">    {  </div>
<div class="line">      _Polygon.Left, _Polygon.Top, 0.0f, 1.0f,</div>
<div class="line">      _TexCoord.Left, _TexCoord.Top,</div>
<div class="line">      _R, _G, _B, _A,</div>
<div class="line">    }, <span class="comment">// 0</span></div>
<div class="line">    {  </div>
<div class="line">      _Polygon.Left, _Polygon.Bottom, 0.0f, 1.0f,</div>
<div class="line">      _TexCoord.Left, _TexCoord.Bottom,</div>
<div class="line">      _R, _G, _B, _A,</div>
<div class="line">    }, <span class="comment">// 1</span></div>
<div class="line">    {  </div>
<div class="line">      _Polygon.Right, _Polygon.Top, 0.0f, 1.0f,</div>
<div class="line">      _TexCoord.Right, _TexCoord.Top,</div>
<div class="line">      _R, _G, _B, _A,</div>
<div class="line">    }, <span class="comment">// 2</span></div>
<div class="line">    {  </div>
<div class="line">      _Polygon.Right, _Polygon.Bottom, 0.0f, 1.0f,</div>
<div class="line">      _TexCoord.Right, _TexCoord.Bottom,</div>
<div class="line">      _R, _G, _B, _A,</div>
<div class="line">    }, <span class="comment">// 3</span></div>
<div class="line">  };</div>
</div><!-- fragment --><div class="fragment"><div class="line">      Component_t::Make(</div>
<div class="line">      {</div>
<div class="line">        { uT(<span class="stringliteral">&quot;id&quot;</span>), uT(<span class="stringliteral">&quot;Simple2DGame.Shader.Pixel.Textured&quot;</span>) },</div>
<div class="line">      }),</div>
<div class="line">      Component_t::Make(</div>
<div class="line">      {</div>
<div class="line">        { uT(<span class="stringliteral">&quot;id&quot;</span>), _TextureId },</div>
<div class="line">      }),</div>
</div><!-- fragment --><div class="fragment"><div class="line">      Component_t::Make(</div>
<div class="line">      {</div>
<div class="line">        { uT(<span class="stringliteral">&quot;id&quot;</span>), uT(<span class="stringliteral">&quot;Simple2DGame.Buffer.Vertex.&quot;</span>) + Id.GetStringId() },</div>
<div class="line">        { uT(<span class="stringliteral">&quot;type&quot;</span>), uT(<span class="stringliteral">&quot;Buffer&quot;</span>) },</div>
<div class="line">        { uT(<span class="stringliteral">&quot;content&quot;</span>), VertexData },</div>
<div class="line">        { uT(<span class="stringliteral">&quot;dimension&quot;</span>), 2 },</div>
<div class="line">      }),</div>
<div class="line">      Component_t::Make(</div>
<div class="line">      {</div>
<div class="line">        { uT(<span class="stringliteral">&quot;id&quot;</span>), uT(<span class="stringliteral">&quot;Simple2DGame.Transform.Rectangle.&quot;</span>) + Id.GetStringId() },</div>
<div class="line">        { uT(<span class="stringliteral">&quot;type&quot;</span>), uT(<span class="stringliteral">&quot;Transform&quot;</span>) },</div>
<div class="line">        { uT(<span class="stringliteral">&quot;service&quot;</span>), Trasform },</div>
<div class="line">      }),</div>
<div class="line">      Component_t::Make(</div>
<div class="line">      {</div>
<div class="line">        { uT(<span class="stringliteral">&quot;id&quot;</span>), uT(<span class="stringliteral">&quot;Simple2DGame.Present.Rectangle&quot;</span>) },</div>
<div class="line">      })</div>
</div><!-- fragment --> <dl class="section note"><dt>Заметки</dt><dd><ul>
<li>Общий для всех объектов вертексный шейдер устанавливается вместе с камерой.</li>
<li>Можно использовать текстуру, содержащую несколько изображений для разных объектов, но при этом все равно необходимо устанавливать компонент этой текстуры <b>каждому</b> объекту, т.к. Present отключает использование текстур после отрисовки объекта.</li>
<li>Цвета вершин и текстуры смешиваются (умножаются): прозрачный тексель остается прозрачным, черный остается черным, белый заменяется вторым цветом).</li>
</ul>
</dd></dl>
<h2>Анимация </h2>
<p>Последовательная отрисовка заранее подготовленных кадров анимации может быть реализована несколькими способами:</p><ul>
<li>Создать для каждого кадра отдельный объект и в дальнейшем отрисовывать эти объекты последовательно (например, перемещая указатель на следующий объект при обновлении сцены).</li>
<li>Создать объект, на который наложена текстура, содержащая <b>все</b> кадры анимации, после чего отрисовывать этот объект, используя компонент State.Scissor для выделения одного кадра и перемещая сам объект таким образом, чтобы отображалась нужная часть текстуры.</li>
<li>Создать объект, на который наложена текстура, содержащая <b>все</b> кадры анимации, после чего отрисовывать этот объект, используя шейдер, который будет менять текстурные координаты таким образом, чтобы отображалась нужная часть текстуры. </li>
</ul>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<div class="ttc" id="aa42360_html"><div class="ttname"><a href="a42360.html">covellite::api::Vertex</a></div><div class="ttdoc">Класс входит в проект Covellite.Api   Класс формата вертексного буфера.</div><div class="ttdef"><b>Definition:</b> Vertex.hpp:34</div></div>
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="index.html">index</a></li><li class="navelem"><a class="el" href="a43632.html">Manual</a></li>
    <li class="footer">Документация по Covellite++. Последние изменения: Пт 16 Окт 2020 15:24:30. Создано системой
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.18 </li>
  </ul>
</div>
</body>
</html>

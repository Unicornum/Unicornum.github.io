<!-- HTML header for doxygen 1.8.15-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-151583584-1"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag() { dataLayer.push(arguments); }
        gtag('js', new Date());
        gtag('config', 'UA-151583584-1');
    </script>
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=9" />
    <meta name="generator" content="Doxygen 1.8.18" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Covellite++: Компонентная система</title>
    <link href="tabs.css" rel="stylesheet" type="text/css" />
    <script type="text/javascript" src="jquery.js"></script>
    <script type="text/javascript" src="dynsections.js"></script>
    <link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
    <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
    <link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="Title.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Covellite++
   &#160;<span id="projectnumber">Version: 2.2.10 Revision: 2577 Platform: x64 Build: 02:51 16.10.2020</span>
   </div>
   <div id="projectbrief">Кроссплатформенный фреймворк для разработки приложений на С++</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Создано системой Doxygen 1.8.18 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Поиск');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Поиск');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('a43641.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Компонентная система </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1>Используемые термины </h1>
<ul>
<li><b>Компонент</b> - объект, содержащий информацию об одном аспекте игрового объекта (таких как текстура, меш, положение и т.п.).</li>
</ul>
<p><b>Игровой</b> <b>объект</b> - объект в игровом мире, содержащий информацию в виде набора компонентов.</p><ul>
<li><b>Игровой</b> <b>мир</b> - набор игровых объектов, разбитый на иерархическую структуру из ячеек, каждая из которых содержит несколько игровых объектов; назначение - оптимизация подгрузки и выгрузки игровых объектов (сразу ячейками).</li>
<li><b>Игровая</b> <b>сцена</b> - набор игровых объектов, непосредственно участвующих в игровом процессе; объекты подгружаются (по мере необходимости) из игрового мира и это именно те объекты, которые должны обновляться в процессе игры.</li>
<li><b>Рендер</b> - объект, предназначенный для отображения игровых объектов в 3D сцене, создается на основе одного или нескольких компонентов.</li>
<li><b>Объект</b> <b>3D</b> <b>сцены</b> - объект (набор рендеров), из которых состоит 3D сцена.</li>
<li><b>3D</b> <b>сцена</b> - набор объектов 3D сцены, которые отображаются в окне программы; является 'зеркалом' той части объектов игровой сцены, которые попадают в поле зрения камеры.</li>
</ul>
<h1>Исходные требования </h1>
<ul>
<li>Не должно производиться никаких лишних действий (вызовов пустых функций), для каждого объекта (игрового и 3D сцены) должен выполнятся набор только ему необходимых действий.</li>
<li>Отсутствие дублирования информации (все объекты, отрисовываемые при помощи одного меша, должны содержать ссылку на единую область памяти с информацией об этом меше).</li>
</ul>
<h1>Компоненты </h1>
<p>Фреймворк предоставляет класс компонента <a class="el" href="a42095.html">Component</a>, а также механизм создания рендеров для этих компонентов с учетом активного графического Api (рендеры создаются через объект класса <a class="el" href="a42359.html">Renders</a>, который может быть получен при помощи функции GetRenders() класса <a class="el" href="a42367.html">Window</a>).</p>
<p>Класс компонента:</p><ul>
<li>Содержит и предоставляет доступ к параметрам, которые используются для создания рендеров.</li>
<li>Параметры (кроме обязательных) могут отсутствовать, для таких параметров предусмотрено значение по умолчанию.</li>
<li>Обязательный параметр <b>id</b> - идентификатор компонента. Для компонентов с одним и тем же идентификатором будет использоваться один и тот же рендер, поэтому объекты, содержащие один и тот же меш, могут содержать компоненты, у которых задан только (один и тот же) идентификатор, а развернутое описание этого компонента можно сделать в другом месте и создать его рендер заранее.</li>
<li>Обязательный параметр <b>type</b> - тип компонента, который определяет способ отрисовки этого компонента.</li>
<li>Параметр <b>kind</b> - дочерний подтип компонента; у некоторых типов не используется.</li>
<li>Первоначальная информация может загружаться в виде строк, в дальнейшем (для ускорения рендеринга) при обновлении игровых объектов значения параметров следует устанавливать того же типа, какой используют рендеры (подробнее см. в описании параметорв компонентов).</li>
</ul>
<dl class="section note"><dt>Заметки</dt><dd>Предполагается, что исходная информация о компоненте будет хранится в узлах xml файла, из которых параметры будут загружаться как атрибуты, у которых имя атрибута будет названием параметра, а значение атрибута - значением параметра.</dd></dl>
<h2>Типы компонентов </h2>
<h3>Data</h3>
<p>Вспомогательный компонент, предназначенный для передачи информации рендерам других типов.</p>
<dl class="section note"><dt>Заметки</dt><dd><ul>
<li>Вспомогательные комопненты следует передавать основному компоненту как параметр <b>service</b> в виде набора std::vector&lt;std::shared_ptr&lt;Component&gt;&gt; (какие данные нужны конкретным рендерам см. в описании соответствующих компонентов).</li>
<li>Идентификатор этого компонента не используется.</li>
</ul>
</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">kind </th><th class="markdownTableHeadNone">Параметры </th><th class="markdownTableHeadNone">Тип параметра (значение по умолчанию) </th><th class="markdownTableHeadNone">Описание параметра  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Position (<a class="el" href="a43641.html#Footnote">1</a>) </td><td class="markdownTableBodyNone">x, y, z </td><td class="markdownTableBodyNone">float (0.0f) </td><td class="markdownTableBodyNone">Положение (координаты) в пространстве  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Rotation (<a class="el" href="a43641.html#Footnote">1</a>) </td><td class="markdownTableBodyNone">x, y, z </td><td class="markdownTableBodyNone">float (0.0f) </td><td class="markdownTableBodyNone">Ориентация (углы поворота вокруг соответствующей оси в радианах) в пространстве  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Scale (<a class="el" href="a43641.html#Footnote">1</a>) </td><td class="markdownTableBodyNone">x, y, z </td><td class="markdownTableBodyNone">float (1.0f) </td><td class="markdownTableBodyNone">Масштабирующие коэффициенты по соответствующим осям  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Rect (<a class="el" href="a43641.html#Footnote">1</a>) </td><td class="markdownTableBodyNone">left, top, right, bottom </td><td class="markdownTableBodyNone">int </td><td class="markdownTableBodyNone">Границы прямоугольника  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone" rowspan="9">Texture </td><td class="markdownTableBodyNone">content (<a class="el" href="a43641.html#Footnote">4</a>) </td><td class="markdownTableBodyNone">covellite::api::Buffer_t&lt;uint8_t&gt; </td><td class="markdownTableBodyNone">Бинарные данные текстуры в формате R8G8B8A8  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">width </td><td class="markdownTableBodyNone">int </td><td class="markdownTableBodyNone">Ширина изображения в пикселях  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">height </td><td class="markdownTableBodyNone">int </td><td class="markdownTableBodyNone">Высота изображения в пикселях  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">name </td><td class="markdownTableBodyNone">String_t </td><td class="markdownTableBodyNone">Имя текстуры в шейдере GLSL  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">index </td><td class="markdownTableBodyNone">int </td><td class="markdownTableBodyNone">Индекс текстуры tX в шейдере HLSL  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">destination </td><td class="markdownTableBodyNone">String_t (albedo) </td><td class="markdownTableBodyNone">Назначение текстуры (albedo, metalness, roughness, normal, occlusion, depth)  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">mipmapping </td><td class="markdownTableBodyNone">bool (false) </td><td class="markdownTableBodyNone">Генерировать mip'ы для текстуры; только для текстур, не используемых как внеэкранные поверхности  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">mapper </td><td class="markdownTableBodyNone">std::function&lt;bool(const void *)&gt; </td><td class="markdownTableBodyNone">Функция обратного вызова для чтения данных текстуры (каждый пиксель - это число uint32_t в формате ABGR)  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">capacity </td><td class="markdownTableBodyNone">int (8) </td><td class="markdownTableBodyNone">Количество бит на каждый канал цвета (8, 16, 32)  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone" rowspan="3">Shader </td><td class="markdownTableBodyNone">content (<a class="el" href="a43641.html#Footnote">4</a>) </td><td class="markdownTableBodyNone">covellite::api::Buffer_t&lt;uint8_t&gt; </td><td class="markdownTableBodyNone">Содержимое текстового файла шейдера в бинарном виде  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">entry </td><td class="markdownTableBodyNone">String_t </td><td class="markdownTableBodyNone">Имя функции точки входа шейдера  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">instance </td><td class="markdownTableBodyNone">String_t </td><td class="markdownTableBodyNone">Описатель (вида 'f4f4i4') структуры <a class="el" href="a43642.html">инстанс-буфера</a>  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone" rowspan="6">Buffer </td><td class="markdownTableBodyNone" rowspan="2">content (<a class="el" href="a43641.html#Footnote">4</a>) </td><td class="markdownTableBodyNone">covellite::api::Buffer_t&lt;<a class="el" href="a42363.html">Vertex</a>&gt; </td><td class="markdownTableBodyNone">Данные вертексного буфера для отрисовки плоских и объемных объектов (<a class="el" href="a43641.html#Footnote">2</a>)  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">covellite::api::Buffer_t&lt;int&gt; </td><td class="markdownTableBodyNone">Данные индексного буфера  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">count </td><td class="markdownTableBodyNone">size_t </td><td class="markdownTableBodyNone">Количество элементов в инстанс-буфере  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone" rowspan="2">mapper </td><td class="markdownTableBodyNone">std::function&lt;bool(void *)&gt; </td><td class="markdownTableBodyNone" rowspan="2">Функция обратного вызова для заполнения <a class="el" href="a43642.html">инстанс-буфера</a>  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">std::function&lt;bool(void *, size_t &amp;)&gt;  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">size </td><td class="markdownTableBodyNone">size_t </td><td class="markdownTableBodyNone">Размер <a class="el" href="a43642.html">инстанс-буфера</a> в байтах  </td></tr>
</table>
<p>Компонент Data.Texture может использоваться для следующих целей:</p><ul>
<li>Цель рендеринга во внеэкранную поверхность (см. компонент BkSurface).</li>
<li>Источник данных для рендеринга текстурированных объектов (см. компонент Texture).</li>
</ul>
<p>В рамках одного прохода (одна и та же камера или <b>BkSurface</b>) Data.Texture может использоваться только в одном качестве, т.е. в первом проходе ее можно передать компоненту <b>BkSurface</b> и она будет использоваться как цель рендеринга (и ее нельзя будет использовать в качестве текстуры объекта), а во втором проходе ее же можно передать компоненту Texture и использовать для рендеринга объектов.</p>
<dl class="section note"><dt>Заметки</dt><dd><ul>
<li>Параметр <b>capacity</b> текстур предназначен исключительно для увеличения точности значений при передаче их между разными проходами рендеринга (мировых координат для расчета теней, например), использовать его для текстур, загруженных из файла не имеет смысла. Текстуры глубины всегда создаются как одноканальные, у которых 24 бита на пиксель.</li>
</ul>
</dd></dl>
<h3>Camera</h3>
<p>Компонент виртуальной камеры.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">kind </th><th class="markdownTableHeadNone">Параметры </th><th class="markdownTableHeadNone">Тип параметра (значение по умолчанию) </th><th class="markdownTableHeadNone">Описание параметра  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Orthographic </td><td class="markdownTableBodyNone">service </td><td class="markdownTableBodyNone">Data.Position </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone" rowspan="5">Perspective </td><td class="markdownTableBodyNone">service </td><td class="markdownTableBodyNone">Data.Position, Data.Rotation </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">distance </td><td class="markdownTableBodyNone">float (0.0f) </td><td class="markdownTableBodyNone">Расстояние от позиции, заданной компонентом Data.Position до камеры  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">fov </td><td class="markdownTableBodyNone">float (90.0f) </td><td class="markdownTableBodyNone">Угол поля зрения по вертикали в градусах  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">znear </td><td class="markdownTableBodyNone">float (0.01f) </td><td class="markdownTableBodyNone">Ближняя плоскость отсечения  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">zfar </td><td class="markdownTableBodyNone">float (200.0f) </td><td class="markdownTableBodyNone">Дальняя плоскость отсечения  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone" rowspan="3">- </td><td class="markdownTableBodyNone">scale </td><td class="markdownTableBodyNone">float (1.0f) </td><td class="markdownTableBodyNone">Масштабирующий коэффициент размеров внеэкранной поверхности относительно размеров окна программы  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">width </td><td class="markdownTableBodyNone">int (ширина окна программы) </td><td class="markdownTableBodyNone">Ширина внеэкранной поверхности в пикселях  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">height </td><td class="markdownTableBodyNone">int (высота окна программы) </td><td class="markdownTableBodyNone">Высота внеэкранной поверхности в пикселях  </td></tr>
</table>
<dl class="section note"><dt>Заметки</dt><dd><ul>
<li>Камера определяет способ отрисовки сцены и ее рендер должен быть первым в списке 3D сцены.</li>
<li>Компонент формирует матрицы вида/проекции и передает их шейдеру (константный буфер шейдера <b>CameraData</b>).</li>
<li>Сформированные матрицы вида/проекции после вызова рендера будут записаны исходному объекту компонента камеры как параметры <b>view</b> и <b>projection</b> в виде объекта класса glm::mat4 (матрицы записываются в том же виде, что и при передаче шейдеру, т.е. транспонированными).</li>
</ul>
</dd>
<dd>
<ul>
<li>Параметры <b>scale</b>, <b>width</b> и <b>height</b> влияют на то, какого размера будет создана внеэкранная поверхность (компонент BkSurface), указанная после компонента камеры:<ul>
<li>Если не указаны параметры <b>scale</b>, <b>width</b> и <b>height</b>, будет создана внеэкранная поверхность с размерами, совпадающими с размерами окна программы; при изменении размеров окна программы размеры внеэкранной поверхности также автоматически изменятся.</li>
<li>Если задан параметр <b>scale</b>, будет создана внеэкранная поверхность с размерами, равными размерам окна программы, домноженными на указанное значение (при этом значения параметров <b>width</b> и <b>height</b> будут проигнорированы); при изменении размеров окна программы размеры внеэкранной поверхности также автоматически изменятся с учетом указанного коэффициента.</li>
<li>Если не указан параметр <b>scale</b> и указаны параметры <b>width</b> и <b>height</b>, будет создана внеэкранная поверхность указанных размеров; при изменении размеров окна программы размеры внеэкранной поверхности меняться не будут.</li>
</ul>
</li>
</ul>
</dd></dl>
<hr  />
<p><b>Ортографическа</b> камера использует левостороннюю систему координат, в которой:</p><ul>
<li>Начало координат находится в левом верхнем углу экрана (viewport'ом в Windows является вся клиентская часть окна, в Android - все за исключением заголовка окна).</li>
<li>Координаты вдоль оси X увеличиваются вправо.</li>
<li>Координаты вдоль оси Y увеличиваются вниз.</li>
<li>Камера смотрит на плоскость Oxy со стороны положительных значений оси Z.</li>
<li>Одному пикселю окна программы соответствует изменение координаты на 1.0f.</li>
</ul>
<dl class="todo"><dt><b><a class="el" href="a41945.html#_todo000004">Необходимо сделать:</a></b></dt><dd><ul>
<li>Добавить картинку с осями координат для Windows и Android.</li>
</ul>
</dd></dl>
<p><b>Перспективная</b> камера использует правостороннюю систему координат:</p><ul>
<li>Координаты вдоль оси X увеличиваются с запада на восток.</li>
<li>Координаты вдоль оси Y увеличиваются с юга на север.</li>
<li>Координаты вдоль оси Z (высота над плоскостью Oxy) увеливаются снизу вверх.</li>
<li>Камера смотрит в точку, заданную компонентом Data.Position с расстояния <b>distance</b> (т.е. реализован вид 'от третьего лица', если нужен вид 'от первого лица', установить distance в ноль).</li>
<li>Data.Rotation - это углы поворота самой камеры относительно точки Data.Position (т.е. направление, <b>обратное</b> направлению взгляда).</li>
<li>Отсутствие компонента Data.Rotation (нулевые значения углов ориентации) соответствует направлению взгляда из точки, смещенной от Data.Position на distance вдоль оси X в положительном направлении.</li>
</ul>
<h3>BkSurface</h3>
<p>Компонент внеэкранной поверхности, предназначен для рендеринга в текстуру(ы).</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">kind </th><th class="markdownTableHeadNone">Параметры </th><th class="markdownTableHeadNone">Тип параметра </th><th class="markdownTableHeadNone">Описание параметра  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone" rowspan="3">- </td><td class="markdownTableBodyNone">service </td><td class="markdownTableBodyNone">Data.Texture </td><td class="markdownTableBodyNone">Набор текстур внеэкранной поверхности  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">width </td><td class="markdownTableBodyNone">int </td><td class="markdownTableBodyNone">Ширина внеэкранной поверхности в пикселях (только чтение)  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">height </td><td class="markdownTableBodyNone">int </td><td class="markdownTableBodyNone">Высота внеэкранной поверхности в пикселях (только чтение)  </td></tr>
</table>
<p>Подробнее о использовании компонента см. <a class="el" href="a43639.html">Рендеринг во внеэкранную поверхность</a>.</p>
<h3>State</h3>
<p>Компонент изменения состояния конвеера рендеринга.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">kind </th><th class="markdownTableHeadNone">Параметры </th><th class="markdownTableHeadNone">Тип параметра </th><th class="markdownTableHeadNone">Описание параметра  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Clear </td><td class="markdownTableBodyNone">color </td><td class="markdownTableBodyNone">uint32_t </td><td class="markdownTableBodyNone">Цвет заливки буфера кадра  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone" rowspan="3">Depth </td><td class="markdownTableBodyNone">enabled </td><td class="markdownTableBodyNone">bool (false) </td><td class="markdownTableBodyNone">Включение/отключение использования буфера глубины (используется инвертированный буфер глубины)  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">clear </td><td class="markdownTableBodyNone">bool (false) </td><td class="markdownTableBodyNone">Включение/отключение очистки буфера глубины  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">overwrite </td><td class="markdownTableBodyNone">bool (true) </td><td class="markdownTableBodyNone">Включение/отключение перезаписи буфера глубины  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Blend </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">Включение использования прозрачности  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Sampler </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">Включение использования сглаживания текстур  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone" rowspan="2">Scissor </td><td class="markdownTableBodyNone">service </td><td class="markdownTableBodyNone">Data.Rect </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">enabled </td><td class="markdownTableBodyNone">bool </td><td class="markdownTableBodyNone">В случае false Data.Rect не нужен  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">AlphaTest </td><td class="markdownTableBodyNone">discard </td><td class="markdownTableBodyNone">float </td><td class="markdownTableBodyNone">Отбрасывание значений цвета, у которых значение Alpha-канала меньше или равно указанному  </td></tr>
</table>
<dl class="section note"><dt>Заметки</dt><dd>Каждая камера при рендеринге отключает:<ul>
<li>Использование внеэкранной поверхности (устаналивает вывод нап экран).</li>
<li>Использование буфера глубины.</li>
<li>Блендинг.</li>
</ul>
</dd></dl>
<h3>Shader</h3>
<p>Компонент шейдера.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">kind </th><th class="markdownTableHeadNone">Параметры </th><th class="markdownTableHeadNone">Тип параметра  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">- </td><td class="markdownTableBodyNone">service </td><td class="markdownTableBodyNone">Data.Shader (<a class="el" href="a43641.html#Footnote">3</a>)  </td></tr>
</table>
<dl class="section note"><dt>Заметки</dt><dd><ul>
<li>Тип создаваемого шейдера (вертексный или пиксельный) выводится автоматически из входного типа данных указанной функции точки входа.</li>
<li>Всем шейдерам в качестве заголовочных файлов передаются:<ul>
<li>Файл, содержащий описания структур для передачи данных шейдеру (<a class="el" href="a41949.html">Fx</a>).</li>
<li>Файл, содержащий описания форматов входных данных шейдеров</li>
</ul>
</li>
<li>Если не указаны бинарные данные шейдера (параметры <b>data</b> и <b>count</b>), вместо них будут использоваться шейдеры по умолчанию (те, что использует фреймворк для рендеринга Gui).</li>
<li>В том случае, если в тексте шейдера содержится ошибка, рендер не будет создан и попытка отрендерить объект без установленного шейдера может привести к падению видеодрайвера. Поэтому хорошей практикой является установка объекту камеры компонентов шейдеров по умолчанию (без передачи данных шейдера <b>content</b>), которые в этом случае позволят отрендерить объект 'абы как'.</li>
</ul>
</dd></dl>
<p>Подробнее о том, как формируется окончательный текст шейдера, передаваемый компилятору, см. <a class="el" href="a43645.html">Шейдеры</a>.</p>
<h3>Texture</h3>
<p>Компонент текстуры.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">kind </th><th class="markdownTableHeadNone">Параметры </th><th class="markdownTableHeadNone">Тип параметра  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">- </td><td class="markdownTableBodyNone">service </td><td class="markdownTableBodyNone">Data.Texture (<a class="el" href="a43641.html#Footnote">3</a>)  </td></tr>
</table>
<p>В шейдерных реализациях для рендеринга требуется специальный пиксельный шейдер, т.к. текстуры просто передаются шейдеру в слоты в соотвествии со следующей логикой:</p><ul>
<li>Если заданы параметры <b>name</b> как TexEnvironment и <b>index</b> как 4, то текстура будет передана слоту, который для унификации шейдера под HLSL и GLSL следует объявлять и использовать как <div class="fragment"><div class="line">COVELLITE_DECLARE_TEX2D(TexEnvironment, 4); <span class="comment">// объявление</span></div>
<div class="line"> </div>
<div class="line">float3 Color = COVELLITE_TEX2D_COLOR(TexEnvironment, TexCoord).rgb; <span class="comment">// использование</span></div>
</div><!-- fragment --></li>
<li>Если параметры <b>name</b> и <b>index</b> не указаны, слот текстуры в шейдере определяется по значению параметра <b>destination</b> <div class="fragment"><div class="line">COVELLITE_DECLARE_TEX2D(TexAlbedo, 0); <span class="comment">// albedo</span></div>
<div class="line">COVELLITE_DECLARE_TEX2D(TexMetalness, 1); <span class="comment">// metalness</span></div>
<div class="line">COVELLITE_DECLARE_TEX2D(TexRoughness, 2); <span class="comment">// roughness</span></div>
<div class="line">COVELLITE_DECLARE_TEX2D(TexNormal, 3); <span class="comment">// normal</span></div>
<div class="line">COVELLITE_DECLARE_TEX2D(TexOcclusion, 4); <span class="comment">// occlusion</span></div>
<div class="line">COVELLITE_DECLARE_TEX2D(TexDepth, 5); <span class="comment">// depth</span></div>
</div><!-- fragment --></li>
<li>Если не указаны параметры <b>name</b>, <b>index</b> и <b>destination</b>, слот текстуры в шейдере будет установлен как <div class="fragment"><div class="line">COVELLITE_DECLARE_TEX2D(TexDiffuse, 0);</div>
</div><!-- fragment --></li>
</ul>
<dl class="section note"><dt>Заметки</dt><dd><ul>
<li>Параметр <b>mapper</b> используется для установки функции обратного вызова, которая вызывается при активации рендера и предназначена для <b>чтения</b> содержимого буфера текстуры (только для текстур, используемых в качестве внеэкранных поверхностей). Нужно понимать, что при этом данные текстуры копируются из видеопамяти в системную память, что является тяжелой операцией и использование ее при каждой активации текстуры (возврат true при каждом вызове функции обратного вызова со значением nullptr) <b>очень</b> <b>сильно</b> ударит по производительности. Чтение данных из текстуры имеет смысл использовать в качестве особой, разовой операции; например, при обработке клика мышью.</li>
</ul>
</dd></dl>
<h3>Buffer</h3>
<p>Компонент буферов геометрии меша и констант шейдера.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">kind </th><th class="markdownTableHeadNone">Параметры </th><th class="markdownTableHeadNone">Тип параметра </th><th class="markdownTableHeadNone">Описание параметра  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone" rowspan="2">Vertex </td><td class="markdownTableBodyNone">service </td><td class="markdownTableBodyNone">Data.Buffer (<a class="el" href="a43641.html#Footnote">3</a>) </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">mapper </td><td class="markdownTableBodyNone">std::function&lt;bool(const <a class="el" href="a42363.html">Vertex</a> *)&gt; </td><td class="markdownTableBodyNone">Функция обратного вызова для изменения буфера  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone" rowspan="4">Constant </td><td class="markdownTableBodyNone">service </td><td class="markdownTableBodyNone">Data.Buffer (<a class="el" href="a43641.html#Footnote">3</a>) </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">mapper </td><td class="markdownTableBodyNone">std::function&lt;bool(const void *)&gt; </td><td class="markdownTableBodyNone">Функция обратного вызова для заполнения <a class="el" href="a43646.html">пользовательского</a> буфера  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">size </td><td class="markdownTableBodyNone">size_t </td><td class="markdownTableBodyNone">Размер константного буфера в байтах (когда в качестве <b>mapper</b> используется std::function&lt;bool(void *)&gt;)  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">name </td><td class="markdownTableBodyNone">String_t </td><td class="markdownTableBodyNone">Имя переменной <a class="el" href="a43646.html">пользовательского</a> буфера в шейдере ('cbUserData' по умолчанию)  </td></tr>
</table>
<dl class="todo"><dt><b><a class="el" href="a41945.html#_todo000005">Необходимо сделать:</a></b></dt><dd>Требуется обобщение способа передачи параметров константного и инстанс-буфера, т.к. они совпадают, но в первом случае они передаются самому компоненту, а во втором - компоненту Data.Buffer.</dd></dl>
<dl class="section note"><dt>Заметки</dt><dd><ul>
<li>Параметр <b>kind</b> можно не указывать, тип буфера выводится автоматически из типа переданных ему данных.</li>
<li>Порядок обхода вершин вертексного буфера - против часовой стрелки.</li>
<li>Если передан параметр <b>mapper</b>, будет создан буфер, который можно изменять (только содержимое, причем можно изменять только часть значений; размер буфера, равный значению параметра <b>count</b> изменить нельзя) прямо во время работы программы. Переданный функциональный объект будет вызываться два раза:<ul>
<li>Со значением параметра nullptr - вернуть true или false в зависимости от того, следует ли обновлять буфер или нет.</li>
<li>С указателем на начало памяти буфера, если обновление требуется (возращаемое значение не используется).</li>
</ul>
</li>
</ul>
</dd></dl>
<hr  />
<p>Логика работы с источниками света через константный буфер с ограниченным количеством слотов для точечных источников света построена исходя из оптимизации расчета освещения каждого объекта (как передача данных, так и расчет освещения для большого количества источников света шейдером очень времязатратная операция, fps катастрофически падает уже при паре десятков источников света в сцене). Сцена может содержать сотни точечных источников света, но здравый смысл подсказывает, что они будут распределены по сцене более-менее равномерно и каждый конкретный объект будет освещен небольшим (единицы) количеством источников света. Поэтому строить набор компонентов объектов сцены имеет смысл следующим образом:</p><ul>
<li>При загрузке сцены все объекты, являющиеся точечными источниками света, добавляют свои параметры в общий список источников света сцены.</li>
<li>Камере добавляется компонент Buffer.Constant, функция обратного вызова которого (<b>mapper</b>) формирует значения фонового и направленного источников света.</li>
<li>Каждому объекту сцены добавляется компонент Buffer.Constant <a class="el" href="a43646.html">пользовательского</a> константного буфера, функция обратного вызова которого перебирает список всех точечных источников света и добавляет в список источников света объекта те, которые освещают его сильнее всего (например, самые близкие).</li>
<li>Расчет радиуса действия для точечного источника света можно посмотреть <a href="https://habr.com/ru/post/420565/">здесь</a>.</li>
<li>Для статичных объектов набор статичных же источников света можно формировать один раз.</li>
</ul>
<h3>Transform</h3>
<p>Компонент установки положения/ориентации/масштабирования объекта.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">kind </th><th class="markdownTableHeadNone">Параметры </th><th class="markdownTableHeadNone">Тип параметра </th><th class="markdownTableHeadNone">Описание параметра  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">- </td><td class="markdownTableBodyNone" rowspan="3">service </td><td class="markdownTableBodyNone" rowspan="2">Data.Position/Rotation/Scale (<a class="el" href="a43641.html#Footnote">3</a>) </td><td class="markdownTableBodyNone">Объект, положение/ориентация/масштаб которого <b>могут</b> изменятся во время работы программы  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Static </td><td class="markdownTableBodyNone">Объект, положение/ориентация/масштаб которого <b>не</b> <b>будут</b> изменятся во время работы программы  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Billboard </td><td class="markdownTableBodyNone">Data.Position (<a class="el" href="a43641.html#Footnote">3</a>) </td><td class="markdownTableBodyNone">Объект, всегда развернутый 'лицом' к камере  </td></tr>
</table>
<dl class="section note"><dt>Заметки</dt><dd><ul>
<li>Компонент формирует матрицу трансформации объекта и передает ее шейдеру (константный буфер шейдера <b>ObjectData.World</b>).</li>
<li>У статического объекта мировая матрица будет вычислена один раз при его создании и в дальнейшем изменить его положение/ориентацию/масштаб будет невозможно; динамический объект захватывает переданные ему компоненты Data, поэтому его положение/ориентацию/масштаб можно менять в каждом кадре изменяя значения параметров этих компонентов.</li>
<li>'Лицом' billboard'a считается плоскость Oxy при взгляде со стороны положительных значений вдоль оси z.</li>
</ul>
</dd></dl>
<h3>Present</h3>
<p>Компонент отправки информации в конвеер рендеринга.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">kind </th><th class="markdownTableHeadNone">Параметры </th><th class="markdownTableHeadNone">Тип параметра  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Index </td><td class="markdownTableBodyNone" rowspan="2">service </td><td class="markdownTableBodyNone">Data.Buffer (<a class="el" href="a43641.html#Footnote">3</a>)  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Instance </td><td class="markdownTableBodyNone">Data.Buffer  </td></tr>
</table>
<dl class="section note"><dt>Заметки</dt><dd><ul>
<li>Компонент Present должен завершать набор компонентов каждого объекта 3D сцены.</li>
<li>Указание значения <b>kind</b> не обязательно; если задан только Buffer.Index, будет создан компонент Present.Index, если заданы и Buffer.Index и Buffer.Instance - <a class="el" href="a43642.html">Present.Instance</a>.</li>
</ul>
</dd></dl>
<h3>Updater</h3>
<p>Компонент обновления объекта. Позволяет установить функциональный объект (функцию обратного вызова), связанную с конкретным объектом.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Параметры </th><th class="markdownTableHeadNone">Тип параметра </th><th class="markdownTableHeadNone">Описание параметра  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">function </td><td class="markdownTableBodyNone">std::function&lt;void(const float)&gt; </td><td class="markdownTableBodyNone">Функциональный объект, который будет вызываться при активации рендера компонента  </td></tr>
</table>
<dl class="section note"><dt>Заметки</dt><dd><ul>
<li>Переданному функциональному объекту при вызове будет передаваться время рендеринга текущего кадра (отсчет ведется с момента запуска программы) в секундах.</li>
<li>Гарантируется, что в рамках рендеринга одного кадра все updater'ы всех объектов получат одно и то же значение времени.</li>
<li>Компоненту можно установить новый функциональный объект в любой момент времени (это может делать даже сам вызванный функциональный объект во время работы, безо всяких ограничений).</li>
</ul>
</dd></dl>
<hr  />
<p>Если необходимо, чтобы updater объекта вызывался только тогда, когда рендерится сам объект (например, когда он находится в поле зрения камеры), то компонент updater'a можно добавить в список компонентов самого объекта и забыть о нем. Если же updater нужно вызывать независимо от того, рендерится объект в текущем кадре или нет, то необходимо компонент его updater'a поместить в отдельный игровой объект и вызывать его рендер индивидуально.</p>
<h2>Сноски </h2>
<p><a class="anchor" id="Footnote"></a></p><ol type="1">
<li>Параметры этих компонентов могут изменяться во время работы программы (т.е. для изменения положения объекта в пространстве не нужно его пересоздавать, достаточно установить новые координаты комопоненту его положения), для изменения остальных (например замены 3D модели объекта) необходимо создать новый набор компонентов, удалить из 3D сцены старый и создать новый объект.</li>
<li>Параметры можно указывать непосредственно основному компоненту, без использования компонента Data.</li>
<li>Может быть несколько компонентов, что можно использовать для привязки (совместного движения) объектов друг к другу (в этом случае необходимо гарантировать, чтобы в качестве общего компонента использовался ОДИН И ТОТ ЖЕ объект, совпадения идентификаторов компонентов недостаточно!).</li>
<li>Содержимое параметра <b>content</b> будет удалено из компонента во время создания рендера.</li>
</ol>
<h1>Общая концепция использования компонентов </h1>
<p>Основная идея работы с 3D объектами предполагает использование архитектуры программы на основе паттерна MVC.</p>
<h2>Модель </h2>
<ul>
<li>Загружает игровой мир как набор ячеек, каждая из которых ссылается на место хранения информации о содержащихся в ячейке объектах.</li>
<li>Содержит базу данных игровых объектов и функции, которые позволяют получать набор компонентов (для обновления и рендеринга) игрового объекта по его идентификатору.</li>
<li>Содержит игровую сцену(ы), которая включает идентификаторы камеры, а также источников света и объектов, находящихся рядом с камерой.</li>
<li>При перемещениях игрока добавляются приблизившиеся к камере и удаляются удалившиеся объекты (группами в ячейках).</li>
<li>На стадии обновления обновляются объекты игровой сцены (можно обновлять объекты постепенно удаляясь от камеры пока не выйдет заданное на обновление время).</li>
</ul>
<h2>Представление </h2>
<ul>
<li>Класс окна, которое создается между окнами Api и Gui.</li>
<li>Содержит, создает и удаляет объекты 3D сцены на основе информации, полученной от модели.</li>
<li>При построении/обновлении 3D сцены первой должна идти камера.</li>
<li>Изменение геометрии/материала производится удалением/добавлением игрового объекта.</li>
</ul>
<h2>Взаимодействие частей кода игры </h2>
<ul>
<li>Панель GUI с кнопками действий игрока (View) подписывается на события нажатия кнопок, при получении которых генерирует события действий игрока.</li>
<li>Игровой мир (Model) подписывается на события действий игрока:<ul>
<li>Обновляет состояние игрока и объектов игровой сцены.</li>
<li>В очередь создания объектов добавляются объекты, которые теперь попадают в зону действия камеры.</li>
<li>Из игровой сцены удаляются объекты, расположенные слишком далеко от камеры.</li>
</ul>
</li>
<li>3D сцена (View):<ul>
<li>По событию создания объекта запрашивает у модели набор компонентов объекта и создает его рендер.</li>
<li>По событию удаления объекта удаляет его рендер.</li>
<li>По событию отрисовки окна запрашивает у модели актуальынй набор игровых объектов и активирует их рендеры.</li>
</ul>
</li>
</ul>
<h1>Примеры использования компонентов </h1>
<p><a class="el" href="a43629.html">Отрисовка 2D объектов</a></p>
<p><a class="el" href="a43631.html">Отрисовка 3D объектов</a> </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="index.html">index</a></li><li class="navelem"><a class="el" href="a43637.html">Структура решения</a></li><li class="navelem"><a class="el" href="a43644.html">Covellite.Api</a></li>
    <li class="footer">Документация по Covellite++. Последние изменения: Пт 16 Окт 2020 02:52:26. Создано системой
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.18 </li>
  </ul>
</div>
</body>
</html>

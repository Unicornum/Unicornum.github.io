<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.16"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Covellite++: Компонентная система</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="Title.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Covellite++
   &#160;<span id="projectnumber">Version: 2.2.2 Revision: 1961 Platform: x64 Build: 21:24 03.09.2019</span>
   </div>
   <div id="projectbrief">Кроссплатформенный (Windows/Android) GUI фреймворк для разработки приложений на С++</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Создано системой Doxygen 1.8.16 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Поиск');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Поиск');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('a36800.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Компонентная система </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1>Используемые термины </h1>
<ul>
<li><b>Компонент</b> - объект, содержащий информацию об одном аспекте игрового объекта (таких как текстура, меш, положение и т.п.).</li>
</ul>
<p><b>Игровой</b> <b>объект</b> - объект в игровом мире, содержащий информацию в виде набора компонентов.</p><ul>
<li><b>Игровой</b> <b>мир</b> - набор игровых объектов, разбитый на иерархическую структуру из ячеек, каждая из которых содержит несколько игровых объектов; назначение - оптимизация подгрузки и выгрузки игровых объектов (сразу ячейками).</li>
<li><b>Игровая</b> <b>сцена</b> - набор игровых объектов, непосредственно участвующих в игровом процессе; объекты подгружаются (по мере необходимости) из игрового мира и это именно те объекты, которые должны обновляться в процессе игры.</li>
<li><b>Рендер</b> - объект, предназначенный для отображения игровых объектов в 3D сцене, создается на основе одного или набора нескольких компонентов.</li>
<li><b>Объект</b> <b>3D</b> <b>сцены</b> - объект (набор рендеров), из которых состоит 3D сцена.</li>
<li><b>3D</b> <b>сцена</b> - набор объектов 3D сцены, которые отображаются в окне программы; является 'зеркалом' той части объектов игровой сцены, которые попадают в поле зрения камеры.</li>
</ul>
<h1>Исходные требования </h1>
<ul>
<li>Не должно производиться никаких лишних действий (вызовов пустых функций), для каждого объекта (игрового и 3D сцены) должен выполнятся набор только ему необходимых действий.</li>
<li>Отсутствие дублирования информации (все объекты, отрисовываемые при помощи одного меша, должны содержать ссылку на единую область памяти с информацией об этом меше).</li>
</ul>
<h1>Компоненты </h1>
<p>Фреймворк предоставляет класс компонента <a class="el" href="a35111.html">Component</a>, а также механизм создания рендеров для этих компонентов с учетом активного графического Api (рендеры создаются через объект класса <a class="el" href="a35415.html">Renders</a>, который может быть получен при помощи функции GetRenders() класса <a class="el" href="a35559.html">Window</a>).</p>
<p>Класс компонента:</p><ul>
<li>Содержит и предоставляет доступ к параметрам, которые используются для создания рендеров.</li>
<li>Параметры (кроме обязательных) могут отсутствовать, для таких параметров предусмотрено задание значений по умолчанию.</li>
<li>Обязательный параметр <b>id</b> - идентификатор компонента. Для компонентов с одним и тем же идентификатором будет использоваться один и тот же рендер, поэтому объекты, содержащие один и тот же меш, могут содержать компоненты, у которых задан только (один и тот же) идентификатор, а развернутое описание этого компонента можно сделать в другом месте и создать его рендер заранее.</li>
<li>Обязательный параметр <b>type</b> - тип компонента, который определяет способ отрисовки этого компонента.</li>
<li>Параметр <b>kind</b> - дочерний подтип компонента; у некоторых типов не используется.</li>
<li>Первоначальная информация может загружаться в виде строк, в дальнейшем (для ускорения рендеринга) при обновлении игровых объектов значения параметров следует устанавливать того же типа, какой используют рендеры (подробнее см. в описании параметорв компонентов).</li>
</ul>
<dl class="section note"><dt>Заметки</dt><dd>Предполагается, что исходная информация о компоненте будет хранится в узлах xml файла, из которых параметры будут загружаться как атрибуты, у которых имя атрибута будет названием параметра, а значение атрибута - значением параметра.</dd></dl>
<h2>Типы компонентов </h2>
<h3>Data</h3>
<p>Вспомогательный компонент, предназначенный для передачи информации рендерам других типов.</p>
<dl class="section note"><dt>Заметки</dt><dd><ul>
<li>Для этого компонента не создается рендера, вместо этого он захватывается и используется следующим рендером, который будет создан (какие данные нужны конкретным рендерам см. в описании соответствующих компонентов).</li>
<li>Идентификатор этого компонента не используется.</li>
</ul>
</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">kind  </th><th class="markdownTableHeadNone">Параметры  </th><th class="markdownTableHeadNone">Тип параметра  </th><th class="markdownTableHeadNone">Описание параметра   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Position (<a class="el" href="a36800.html#Footnote">1</a>)  </td><td class="markdownTableBodyNone">x, y, z  </td><td class="markdownTableBodyNone">float  </td><td class="markdownTableBodyNone">Положение (координаты) в пространстве (0.0f по умолчанию)   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Rotation (<a class="el" href="a36800.html#Footnote">1</a>)  </td><td class="markdownTableBodyNone">x, y, z  </td><td class="markdownTableBodyNone">float  </td><td class="markdownTableBodyNone">Ориентация (углы поворота вокруг соответствующей оси в радианах) в пространстве (0.0f по умолчанию)   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Scale (<a class="el" href="a36800.html#Footnote">1</a>)  </td><td class="markdownTableBodyNone">x, y, z  </td><td class="markdownTableBodyNone">float  </td><td class="markdownTableBodyNone">Масштабирующие коэффициенты по соответствующим осям (1.0f по умолчанию)   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Direction (<a class="el" href="a36800.html#Footnote">1</a>)  </td><td class="markdownTableBodyNone">x, y, z  </td><td class="markdownTableBodyNone">float  </td><td class="markdownTableBodyNone">Вектор направления (из указанной точки в начало координат) в пространстве   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Attenuation (<a class="el" href="a36800.html#Footnote">1</a>)  </td><td class="markdownTableBodyNone">const, linear, exponent  </td><td class="markdownTableBodyNone">float  </td><td class="markdownTableBodyNone">Настройки затухания для точечного источника света   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Rect (<a class="el" href="a36800.html#Footnote">1</a>)  </td><td class="markdownTableBodyNone">left, top, right, bottom  </td><td class="markdownTableBodyNone">int  </td><td class="markdownTableBodyNone">Границы прямоугольника   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone" rowspan="4">Texture  </td><td class="markdownTableBodyNone">data  </td><td class="markdownTableBodyNone">const uint8_t *  </td><td class="markdownTableBodyNone">Бинарные данные текстуры в формате R8G8B8A8   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">width  </td><td class="markdownTableBodyNone">int  </td><td class="markdownTableBodyNone">Ширина изображения в пикселях   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">height  </td><td class="markdownTableBodyNone">int  </td><td class="markdownTableBodyNone">Высота изображения в пикселях   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">destination  </td><td class="markdownTableBodyNone">String_t  </td><td class="markdownTableBodyNone">Назначение текстуры (albedo (по умолчанию), metalness, roughness, normal, occlusion)   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone" rowspan="3">Shader  </td><td class="markdownTableBodyNone">data  </td><td class="markdownTableBodyNone">const uint8_t *  </td><td class="markdownTableBodyNone">Содержимое текстового файла шейдера в бинарном виде   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">count  </td><td class="markdownTableBodyNone">size_t  </td><td class="markdownTableBodyNone">Размер буфера данных шейдера в байтах   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">entry  </td><td class="markdownTableBodyNone">String_t  </td><td class="markdownTableBodyNone">Имя функции точки входа шейдера   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone" rowspan="6">Buffer  </td><td class="markdownTableBodyNone" rowspan="4">data  </td><td class="markdownTableBodyNone">const <a class="el" href="a35539.html">Vertex::Polygon</a> *  </td><td class="markdownTableBodyNone">Данные вертексного буфера для отрисовки плоских объектов (<a class="el" href="a36800.html#Footnote">2</a>)   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">const <a class="el" href="a35543.html">Vertex::Polyhedron</a> *  </td><td class="markdownTableBodyNone">Данные вертексного буфера для отрисовки объемных объектов   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">const <a class="el" href="a35547.html">Vertex</a> *  </td><td class="markdownTableBodyNone">Данные вертексного буфера для отрисовки объектов любого типа   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">const int *  </td><td class="markdownTableBodyNone">Данные индексного буфера   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">count  </td><td class="markdownTableBodyNone">size_t  </td><td class="markdownTableBodyNone">Количество элементов в буфере, переданном в <b>data</b>   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">dimension  </td><td class="markdownTableBodyNone">int  </td><td class="markdownTableBodyNone">2 или 3 (по умолчанию) - размерность отрисовываемого объекта   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone" rowspan="3">Fog  </td><td class="markdownTableBodyNone">color  </td><td class="markdownTableBodyNone">uint32_t  </td><td class="markdownTableBodyNone">Цвет тумана в формате ARGB (0xFFFFFFFF)   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">near, far  </td><td class="markdownTableBodyNone">float  </td><td class="markdownTableBodyNone">Расстояния до передней и задней дистанции при расчете тумана (нужны для linear)   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">density  </td><td class="markdownTableBodyNone">float  </td><td class="markdownTableBodyNone">Коэффициент, определяющий скорость возрастания плотности тумана (нужен для exp и exp2)   </td></tr>
</table>
<dl class="section note"><dt>Заметки</dt><dd>Параметр <b>dimension</b> для вертексного буфера имеет смысл только для формата вершин <a class="el" href="a35547.html">Vertex</a> и реализаций со статическим конвеером для указания того, как следует интерпретировать данные вертексного буфера - 2D или 3D объекты; шейдерные реализации просто передают буфер шейдеру и поэтому следует устанавливать шейдер, который будет правильно использовать переданные данные.</dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="a34950.html#_deprecated000001">Уст.:</a></b></dt><dd>Форматы <a class="el" href="a35539.html">Vertex::Polygon</a> и <a class="el" href="a35543.html">Vertex::Polyhedron</a> для вертексного буфера считаются устаревшими и будут удалены в следующей стабильной версии, вместо них следует использовать формат <a class="el" href="a35547.html">Vertex</a> с правильно установленным вертексным шейдером.</dd></dl>
<h3>Camera</h3>
<p>Камера определяет способ отрисовки сцены и ее рендер должен быть первым в списке 3D сцены.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">kind  </th><th class="markdownTableHeadNone">Требуется Data (kind)  </th><th class="markdownTableHeadNone">Параметры  </th><th class="markdownTableHeadNone">Тип параметра  </th><th class="markdownTableHeadNone">Описание параметра   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Orthographic  </td><td class="markdownTableBodyNone">Position  </td><td class="markdownTableBodyNone">-  </td><td class="markdownTableBodyNone">-  </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone" rowspan="2">Perspective  </td><td class="markdownTableBodyNone" rowspan="2">Position, Rotation  </td><td class="markdownTableBodyNone">distance  </td><td class="markdownTableBodyNone">float  </td><td class="markdownTableBodyNone">Расстояние от позиции, заданной компонентом Data.Position до камеры   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">fov  </td><td class="markdownTableBodyNone">float  </td><td class="markdownTableBodyNone">Угол поля зрения по вертикали в градусах   </td></tr>
</table>
<p><b>Ортографическа</b> камера использует левостороннюю систему координат, в которой:</p><ul>
<li>Начало координат находится в левом верхнем углу экрана (viewport'ом в Windows является вся клиентская часть окна, в Android - все за исключением заголовка окна).</li>
<li>Координаты вдоль оси X увеличиваются вправо.</li>
<li>Координаты вдоль оси Y увеличиваются вниз.</li>
<li>Камера смотрит на плоскость Oxy со стороны положительных значений оси Z.</li>
<li>Одному пикселю окна программы соответствует изменение координаты на 1.0f.</li>
</ul>
<dl class="todo"><dt><b><a class="el" href="a34949.html#_todo000004">Необходимо сделать:</a></b></dt><dd><ul>
<li>Добавить картинку с осями координат для Windows и Android.</li>
</ul>
</dd></dl>
<p><b>Перспективная</b> камера использует правостороннюю систему координат:</p><ul>
<li>Координаты вдоль оси X увеличиваются с запада на восток.</li>
<li>Координаты вдоль оси Y увеличиваются с юга на север.</li>
<li>Координаты вдоль оси Z (высота над плоскостью Oxy) увеливаются снизу вверх.</li>
<li>Камера смотрит в точку, заданную компонентом Data.Position с расстояния <b>distance</b> (т.е. реализован вид 'от третьего лица', если нужен вид 'от первого лица', установить distance в ноль).</li>
<li>Data.Rotation - это углы поворота самой камеры относительно точки Data.Position (т.е. направление, <b>обратное</b> направлению взгляда).</li>
<li>Отсутствие компонента Data.Rotation или нулевые значения углов ориентации соответствуют направлению взгляда из точки, смещенной от Data.Position на distance вдоль оси X в положительном направлении.</li>
</ul>
<h3>State</h3>
<p>Компонент изменения состояния конвеера рендеринга.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">kind  </th><th class="markdownTableHeadNone">Требуется Data (kind)  </th><th class="markdownTableHeadNone">Параметры  </th><th class="markdownTableHeadNone">Тип параметра  </th><th class="markdownTableHeadNone">Описание параметра   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Clear  </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">color  </td><td class="markdownTableBodyNone">uint32_t  </td><td class="markdownTableBodyNone">Цвет заливки буфера кадра   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone" rowspan="3">Depth  </td><td class="markdownTableBodyNone" rowspan="3"></td><td class="markdownTableBodyNone">enabled  </td><td class="markdownTableBodyNone">bool (false)  </td><td class="markdownTableBodyNone">Включение/отключение использования буфера глубины   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">clear  </td><td class="markdownTableBodyNone">bool (false)  </td><td class="markdownTableBodyNone">Включение/отключение очистки буфера глубины   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">overwrite  </td><td class="markdownTableBodyNone">bool (true)  </td><td class="markdownTableBodyNone">Включение/отключение перезаписи буфера глубины   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Blend  </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">Включение использования прозрачности   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Sampler  </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Scissor  </td><td class="markdownTableBodyNone">Rect  </td><td class="markdownTableBodyNone">enabled  </td><td class="markdownTableBodyNone">bool  </td><td class="markdownTableBodyNone">В случае false Data.Rect не нужен   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">AlphaTest  </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">discard  </td><td class="markdownTableBodyNone">float  </td><td class="markdownTableBodyNone">Отбрасывание значений цвета, у которых значение Alpha-канала меньше или равно указанному   </td></tr>
</table>
<dl class="section note"><dt>Заметки</dt><dd>Каждая камера при рендеринге отключает:<ul>
<li>Использование буфера глубины.</li>
<li>Блендинг.</li>
<li>Alpha test (компонент имеет смысл только для реализаций со статическим конвеером; реализации, которые используют шейдеры, должны делать это при помощи шейдера).</li>
</ul>
</dd></dl>
<h3>Light</h3>
<p>Компонент источника света.</p>
<p>Логика использования источников света предполагает:</p><ul>
<li>Активация рендера камеры создает новую сцену, в которой по умолчанию источники света отсутствуют (поэтому, если - например - требуется отрисовать несколько объектов без использования освещения, следует выделить их в отдельную сцену со своей уникальной камерой).</li>
<li>Компоненты источников света могут располагаться в любом месте списка объектов при создании рендеров (при этом необходимо учитывать, что рендеры источников света добавляют информацию о себе в список источников света текущей сцены (другими словами - активной камеры), а при рендеринге текущего кадра используются источники света, установленные во время рендеринга предыдущего кадра).</li>
</ul>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">kind  </th><th class="markdownTableHeadNone">Требуется Data (kind)  </th><th class="markdownTableHeadNone">Параметры  </th><th class="markdownTableHeadNone">Тип параметра  </th><th class="markdownTableHeadNone">Описание параметра   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Ambient  </td><td class="markdownTableBodyNone">-  </td><td class="markdownTableBodyNone">color  </td><td class="markdownTableBodyNone">uint32_t  </td><td class="markdownTableBodyNone">Цвет (ambient) в формате ARGB (0xFF00FF00)   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Direction  </td><td class="markdownTableBodyNone">Direction  </td><td class="markdownTableBodyNone">color  </td><td class="markdownTableBodyNone">uint32_t  </td><td class="markdownTableBodyNone">Цвет (diffuse и specular) в формате ARGB (0xFF00FF00)   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Point  </td><td class="markdownTableBodyNone">Position, Attenuation  </td><td class="markdownTableBodyNone">color  </td><td class="markdownTableBodyNone">uint32_t  </td><td class="markdownTableBodyNone">Цвет (diffuse и specular) в формате ARGB (0xFF00FF00)   </td></tr>
</table>
<p>При использовании точечных источников света следует учитывать, что реализации, использующие статический конвеер (с этим ничего нельзя сделать), а также шейдеры, предоставляемые фреймворком по умолчанию (для унификации результата отрисовки на разных устройствах) реализуют расчет освещения по Гуро (вычисляются цвета вершин, промежуточные получаются путем интерполяции). Т.е. источник света рядом с большой поверхностью, заданной четырьмя вершинами (факел на стене) не даст реалистичного круглого пятна света - вместо этого будет получена однотонная слабо освещенная поверхность, т.к. вершины расположены далеко и (скорее всего) будут иметь черный цвет. В этом случае следует использовать карты освещения или написать собственный шейдер, реализующий другой метод расчета освещения.</p>
<p>Пример использования разных типов расчета освещения применительно к одной и той же плоскости, заданной четырьмя вершинами:</p>
<div class="image">
<img src="Lights.png" alt=""/>
</div>
<dl class="section note"><dt>Заметки</dt><dd><ul>
<li>Фоновых и направленных источников света может быть не более одного, точечных может быть несколько.</li>
<li>Пропущенные параметры устанавливаются в 0xFF000000.</li>
<li>Параметры компонента Data.Attenuation используются следующим образом: <br  />
 bright = color / (const + (linear + exponent * distance) * distance).</li>
<li>При удалении точечных источников света из 3D сцены следует учитывать, что источник света, не попадающий в поле зрения камеры тем не менее может освещать объекты, попадающие в поле зрения камеры.</li>
<li>Если используется рендеринг при помощи шейдеров (DirectX10/11), то информация об источниках света просто передается пиксельному шейдеру и необходимо самостоятельно задействовать эту информацию в шейдере (форматы передачи данных шейдерам см. <a class="el" href="a34954.html">Fx</a>); также для рендеринга сцены без источников света следует использовать пиксельный шейдер, который не использует информацию об источниках света.</li>
</ul>
</dd></dl>
<h3>Fog</h3>
<p>Компонент тумана.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">kind  </th><th class="markdownTableHeadNone">Требуется Data (kind)  </th><th class="markdownTableHeadNone">Параметры  </th><th class="markdownTableHeadNone">Тип параметра  </th><th class="markdownTableHeadNone">Описание параметра   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">-  </td><td class="markdownTableBodyNone">Fog (<a class="el" href="a36800.html#Footnote">3</a>)  </td><td class="markdownTableBodyNone">style  </td><td class="markdownTableBodyNone">String_t  </td><td class="markdownTableBodyNone">Тип тумана: linear (по умолчанию), exp, exp2   </td></tr>
</table>
<dl class="section note"><dt>Заметки</dt><dd><ul>
<li>Шейдерные реализации просто передают параметры шейдеру и их необходимо явно задействовать в оном.</li>
<li>Камера при рендеринге отключает использование тумана.</li>
</ul>
</dd></dl>
<h3>Material</h3>
<p>Компонент материала (нужен для расчета освещения).</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Параметры  </th><th class="markdownTableHeadNone">Тип параметра  </th><th class="markdownTableHeadNone">Описание параметра   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">ambient  </td><td class="markdownTableBodyNone">uint32_t  </td><td class="markdownTableBodyNone">Цвет в формате ARGB (0xFF333333)   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">diffuse  </td><td class="markdownTableBodyNone">uint32_t  </td><td class="markdownTableBodyNone">Цвет в формате ARGB (0xFFCCCCCC)   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">specular  </td><td class="markdownTableBodyNone">uint32_t  </td><td class="markdownTableBodyNone">Цвет в формате ARGB (0xFF000000)   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">emission  </td><td class="markdownTableBodyNone">uint32_t  </td><td class="markdownTableBodyNone">Цвет в формате ARGB (0xFF000000)   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">shininess  </td><td class="markdownTableBodyNone">int32_t  </td><td class="markdownTableBodyNone">Значение в диапазоне 0...0x80   </td></tr>
</table>
<dl class="section note"><dt>Заметки</dt><dd><ul>
<li>Компонент имеет смысл только для реализаций со статическим конвеером, шейдерные реализации должны использовать PBR-текстурирование.</li>
<li>Материал должен устанавливаться для каждого объекта 3D сцены, которому требуется расчет освещения.</li>
<li>Пропущенные параметры устанавливаются в 0xFF000000.</li>
</ul>
</dd></dl>
<h3>Shader</h3>
<p>Компонент шейдера.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">kind  </th><th class="markdownTableHeadNone">Требуется Data (kind)   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">-  </td><td class="markdownTableBodyNone">Shader (<a class="el" href="a36800.html#Footnote">3</a>)   </td></tr>
</table>
<dl class="section note"><dt>Заметки</dt><dd><ul>
<li>Тип создаваемого шейдера (вертексный или пиксельный) выводится автоматически из входного типа данных указанной функции точки входа.</li>
<li>Всем шейдерам в качестве заголовочных файлов передаются:<ul>
<li>Файл, содержащий описания структур для передачи данных шейдеру (<a class="el" href="a34954.html">Fx</a>).</li>
<li>Файл, содержащий описания форматов входных данных шейдеров</li>
</ul>
</li>
<li>Если не указаны бинарные данные шейдера (параметры <b>data</b> и <b>count</b>), вместо них будут использоваться шейдеры по умолчанию (те, что использует фреймворк для рендеринга Gui).</li>
<li>В том случае, если в тексте шейдера содержится ошибка, рендер не будет создан и попытка отрендерить объект без установленного шейдера может привести к падению видеодрайвера. Поэтому хорошей практикой является установка объекту камеры компонентов шейдеров по умолчанию (без передачи данных шейдера <b>data</b> и <b>count</b>), которые в этом случае позволят отрендерить объект 'абы как'.</li>
</ul>
</dd></dl>
<p>Подробнее о том, как формируется окончательный текст шейдера, передаваемый компилятору, см. <a class="el" href="a36803.html">Шейдеры</a>.</p>
<h3>Texture</h3>
<p>Компонент текстуры.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">kind  </th><th class="markdownTableHeadNone">Требуется Data (kind)   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">-  </td><td class="markdownTableBodyNone">Texture (<a class="el" href="a36800.html#Footnote">3</a>)   </td></tr>
</table>
<dl class="section note"><dt>Заметки</dt><dd><ul>
<li>Параметр <b>destination</b> компонента данных текстуры предназначен для указания роли текстуры в рамках логики <b>PBR-текстурирования</b>.</li>
<li>В шейдерных реализациях для рендеринга с использованием PBR требуется специальный пиксельный шейдер, т.к. текстуры просто передаются шейдеру в слоты:<ul>
<li>HLSL (<b>albedo</b> - t0, <b>metalness</b> - t1, <b>roughness</b> - t2, <b>normal</b> - t3, <b>occlusion</b> - t4).</li>
<li>GLSL (роль не указана - TexDiffuse, <b>albedo</b> - TexAlbedo, <b>metalness</b> - TexMetalness, <b>roughness</b> - TexRoughness, <b>normal</b> - TexNormal, <b>occlusion</b> - TexOcclusion).</li>
</ul>
</li>
<li>Реализации со статическим конвеером используют только единственную текстуру (тип можно не указывать), устанавливая ее в нулевой текстурный слот.</li>
</ul>
</dd></dl>
<h3>Buffer</h3>
<p>Компонент буферов геометрии меша.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">kind  </th><th class="markdownTableHeadNone">Требуется Data (kind)  </th><th class="markdownTableHeadNone">Параметры  </th><th class="markdownTableHeadNone">Тип параметра  </th><th class="markdownTableHeadNone">Описание параметра   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone" rowspan="2">-  </td><td class="markdownTableBodyNone" rowspan="2">Buffer (<a class="el" href="a36800.html#Footnote">3</a>)  </td><td class="markdownTableBodyNone" rowspan="2">mapper  </td><td class="markdownTableBodyNone">cbBufferMap_t&lt;<a class="el" href="a35543.html">Vertex::Polyhedron</a>&gt;  </td><td class="markdownTableBodyNone" rowspan="2">Функция обратного вызова для изменения буфера   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">cbBufferMap_t&lt;<a class="el" href="a35547.html">Vertex</a>&gt;   </td></tr>
</table>
<dl class="section note"><dt>Заметки</dt><dd><ul>
<li>Порядок обхода вершин вертексного буфера - против часовой стрелки.</li>
<li>Если передан параметр <b>mapper</b>, будет создан буфер, который можно изменять (только содержимое, причем можно изменять только часть значений; размер буфера, равный значению параметра <b>count</b> изменить нельзя) прямо во время работы программы. Переданный функциональный объект будет вызываться два раза:<ul>
<li>Со значением параметра nullptr - вернуть true или false в зависимости от того, следует ли в этом кадре обновлять буфер или нет.</li>
<li>С указателем на начало памяти буфера, если обновление требуется (возращаемое значение не используется).</li>
</ul>
</li>
</ul>
</dd></dl>
<h3>Present</h3>
<p>Компонент отправки информации в конвеер рендеринга.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">kind  </th><th class="markdownTableHeadNone">Требуется Data (kind)  </th><th class="markdownTableHeadNone">Параметры  </th><th class="markdownTableHeadNone">Тип параметра  </th><th class="markdownTableHeadNone">Описание параметра   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone" rowspan="3">Geometry  </td><td class="markdownTableBodyNone" rowspan="2">Position/Rotation/Scale (<a class="el" href="a36800.html#Footnote">4</a>)  </td><td class="markdownTableBodyNone" rowspan="3">variety  </td><td class="markdownTableBodyNone" rowspan="3">String_t  </td><td class="markdownTableBodyNone">Параметр отсутствует - динамический объект   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Static - статический объект   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Position (<a class="el" href="a36800.html#Footnote">4</a>)  </td><td class="markdownTableBodyNone">Billboard - объект, всегда развернутый 'лицом' к камере   </td></tr>
</table>
<dl class="section note"><dt>Заметки</dt><dd><ul>
<li>Компонент Present должен завершать набор компонентов каждого объекта 3D сцены и должен иметь уникальный id для каждого конкретного объекта.</li>
<li>У статического объекта мировая матрица будет вычислена один раз при его создании и в дальнейшем изменить его положение/ориентацию/масштаб будет невозможно; динамический объект захватывает переданные ему компоненты Data, поэтому его положение/ориентацию/масштаб можно менять в каждом кадре изменяя значения параметров этих компонентов.</li>
<li>'Лицом' billboard'a считается плоскость Oxy при взгляде со стороны положительных значений вдоль оси z.</li>
</ul>
</dd></dl>
<h3>Updater</h3>
<p>Компонент обновления объекта. Позволяет установить функциональный объект (функцию обратного вызова), связанную с конкретным объектом.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Параметры  </th><th class="markdownTableHeadNone">Тип параметра  </th><th class="markdownTableHeadNone">Описание параметра   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">function  </td><td class="markdownTableBodyNone">std::function&lt;void(const float)&gt;  </td><td class="markdownTableBodyNone">Функциональный объект, который будет вызываться при активации рендера компонента   </td></tr>
</table>
<dl class="section note"><dt>Заметки</dt><dd><ul>
<li>Переданному функциональному объекту при вызове будет передаваться время рендеринга текущего кадра (отсчет ведется с момента запуска программы) в секундах.</li>
<li>Гарантируется, что в рамках рендеринга одного кадра все updater'ы всех объектов получат одно и то же значение времени.</li>
<li>Компоненту можно установить новый функциональный объект в любой момент времени (это может делать даже сам вызванный функциональный объект во время работы, безо всяких ограничений).</li>
<li>Если необходимо, чтобы updater объекта вызывался только тогда, когда рендерится сам объект (например, когда он находится в поле зрения камеры), то компонент updater'a можно добавить в список компонентов самого объекта и забыть о нем. Если же updater нужно вызывать независимо от того, рендерится объект в текущем кадре или нет, то необходимо компонент его updater'a поместить в отдельный игровой объект и вызывать его рендер индивидуально.</li>
</ul>
</dd></dl>
<h2>Сноски </h2>
<p><a class="anchor" id="Footnote"></a></p><ol type="1">
<li>Параметры этих компонентов могут изменяться во время работы программы (т.е. для изменения положения объекта в пространстве не нужно его пересоздавать, достаточно установить новые координаты комопоненту его положения), для изменения остальных (например замены 3D модели объекта) необходимо создать новый набор компонентов, удалить из 3D сцены старый и создать новый объект.</li>
<li><a class="el" href="a35539.html">Vertex::Polygon</a> создан специально для рендеринга элементов Gui и соответствует формату данных, получаемых от libRocket.</li>
<li>Параметры можно указывать непосредственно основному компоненту, без использования компонента Data.</li>
<li>Может быть несколько компонентов, что можно использовать для привязки (совместного движения) объектов друг к другу (в этом случае необходимо гарантировать, чтобы в качестве общего компонента использовался ОДИН И ТОТ ЖЕ объект, совпадения идентификаторов компонентов недостаточно!).</li>
</ol>
<h1>Общая концепция использования компонентов </h1>
<p>Основная идея работы с 3D объектами предполагает использование архитектуры программы на основе паттерна MVC.</p>
<h2>Модель </h2>
<ul>
<li>Загружает игровой мир как набор ячеек, каждая из которых ссылается на место хранения информации о содержащихся в ячейке объектах.</li>
<li>Содержит базу данных игровых объектов и функции, которые позволяют получать набор компонентов (для обновления и рендеринга) игрового объекта по его идентификатору.</li>
<li>Содержит игровую сцену(ы), которая включает идентификаторы камеры, а также источников света и объектов, находящихся рядом с камерой.</li>
<li>При перемещениях игрока добавляются приблизившиеся к камере и удаляются удалившиеся объекты (группами в ячейках).</li>
<li>На стадии обновления обновляются объекты игровой сцены (можно обновлять объекты постепенно удаляясь от камеры пока не выйдет заданное на обновление время).</li>
</ul>
<h2>Представление </h2>
<ul>
<li>Класс окна, которое создается между окнами Api и Gui.</li>
<li>Содержит, создает и удаляет объекты 3D сцены на основе информации, полученной от модели.</li>
<li>При построении/обновлении 3D сцены первой должна идти камера.</li>
<li>Изменение геометрии/материала производится удалением/добавлением игрового объекта.</li>
</ul>
<h2>Взаимодействие частей кода игры </h2>
<ul>
<li>Панель GUI с кнопками действий игрока (View) подписывается на события нажатия кнопок, при получении которых генерирует события действий игрока.</li>
<li>Игровой мир (Model) подписывается на события действий игрока:<ul>
<li>Обновляет состояние игрока и объектов игровой сцены.</li>
<li>В очередь создания объектов добавляются объекты, которые теперь попадают в зону действия камеры.</li>
<li>Из игровой сцены удаляются объекты, расположенные слишком далеко от камеры.</li>
</ul>
</li>
<li>3D сцена (View):<ul>
<li>По событию создания объекта запрашивает у модели набор компонентов объекта и создает его рендер.</li>
<li>По событию удаления объекта удаляет его рендер.</li>
<li>По событию отрисовки окна запрашивает у модели актуальынй набор игровых объектов и активирует их рендеры.</li>
</ul>
</li>
</ul>
<h1>Примеры использования компонентов </h1>
<p><a class="el" href="a36789.html">Отрисовка 2D объектов</a></p>
<p><a class="el" href="a36791.html">Отрисовка 3D объектов</a> </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="a36797.html">Структура решения</a></li><li class="navelem"><a class="el" href="a36802.html">Covellite.Api</a></li>
    <li class="footer">Документация по Covellite++. Последние изменения: Вт 3 Сен 2019 21:24:40. Создано системой
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.16 </li>
  </ul>
</div>
</body>
</html>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Covellite++: Отрисовка 3D объектов</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="Title.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Covellite++
   &#160;<span id="projectnumber">Version: 2.2.0 Revision: 1644 Platform: x64 Build: 14:50 09.05.2019</span>
   </div>
   <div id="projectbrief">Кроссплатформенный (Windows/Android) GUI фреймворк для разработки приложений на С++</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Создано системой Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Поиск');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Поиск');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('a35490.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Отрисовка 3D объектов </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Описание отрисовки 3D объектов в окне с использованием <a class="el" href="a35499.html">компонентной системы</a>.</p>
<h1>Используемые термины </h1>
<ul>
<li><b>Компонент</b> - объект, содержащий информацию об одном аспекте игрового объекта (таких как текстура, меш, положение и т.п.).</li>
<li><b>Игровой</b> <b>объект</b> - объект в игровом мире, содержащий информацию в виде набора компонентов.</li>
<li><b>Игровой</b> <b>мир</b> - набор игровых объектов, разбитый на иерархическую структуру из ячеек, каждая из которых содержит несколько игровых объектов; назначение - оптимизация подгрузки и выгрузки игровых объектов (сразу ячейками).</li>
<li><b>Игровая</b> <b>сцена</b> - набор игровых объектов, непосредственно участвующих в игровом процессе; объекты подгружаются (по мере необходимости) из игрового мира и это именно те объекты, которые должны обновляться в процессе игры.</li>
<li><b>Рендер</b> - объект, предназначенный для отображения игровых объектов в 3D сцене, создается на основе одного или набора нескольких компонентов.</li>
<li><b>Объект</b> <b>3D</b> <b>сцены</b> - объект (набор рендеров), из которых состоит 3D сцена.</li>
<li><b>3D</b> <b>сцена</b> - набор объектов 3D сцены, которые отображаются в окне программы; является 'зеркалом' той части объектов игровой сцены, которые попадают в поле зрения камеры.</li>
</ul>
<dl class="section note"><dt>Заметки</dt><dd><ul>
<li>В данном описании под <b>объектом</b> подразумевается 'объект 3D сцены', а под <b>сценой</b> - '3D сцена'.</li>
<li>Обозначение компонента как State.Scissor подразумевает объект компонента, у которого установлены параметры type == 'State' и kind == 'Scissor'.</li>
<li>Под <b>объектом</b> <b>компонента</b> подразумевается объект C++ класса компонента.</li>
</ul>
</dd></dl>
<p>Подробнее о компонентах и их параметрах см. <a class="el" href="a35499.html">Компонентная система</a>.</p>
<h1>Общее описание </h1>
<p>Используемый формат вершин:</p>
<div class="fragment"><div class="line">  <span class="keyword">using</span> Vertex_t = <a class="code" href="a34444.html">::covellite::api::Vertex::Polyhedron</a>;</div></div><!-- fragment --><p> Отрисовка производится при помощи формирования <b>сцены</b>, содержащей рендеры:</p><ul>
<li><b>Камеры</b> - уникальный объект, определяющий способ отрисовки сцены.</li>
<li><b>Общих</b> <b>объектов</b> (настройки конвеера рендеринга и источники света).</li>
<li><b>Объектов</b>, которые непосредственно формируют требуемое изображение на экране.</li>
</ul>
<p>Сцен может быть несколько, при рендеринге нескольких сцен текущая сцена будет отрисоваваться поверх предыдущей; также можно сформировать несколько различных сцен, каждую из которых отрисовывать в зависимости от неких условий.</p>
<p>Создание и удаление рендеров для компонентов производится через объект, получаемый при помощи функции <a class="el" href="a34240.html#ae3b6fea02ea2cb4fd940582edc7ee034" title="Функция получения объекта создания/удаления рендеров для компонентов.">covellite::api::IWindow::GetRenders()</a>.</p>
<dl class="section warning"><dt>Предупреждения</dt><dd>Реализация OpenGL требует, чтобы рендеры создавались и активировались в том же потоке, в котором было создано окно графического Api.</dd></dl>
<dl class="section note"><dt>Заметки</dt><dd>При создании рендеров для разных <b>объектов</b> <b>компонентов</b> с одним и тем же <b>id</b> будет возвращен один и тот же объект рендера (это позволяет, например, один раз сформировать набор общих для всех объектов рендеров, а затем обращаться к ним через <b>объекты</b> <b>компонентов</b>, содержащих только идентификаторы), но при этом следует учитывать, что для некоторых типов компонентов рендеры не создаются (например, компоненты Data вместо этого захватываются и используются рендерами других компонентов). Для таких компонентов параметр <b>id</b> не имеет смысла и при необходимости использования несколькими объектами одного и того же компонента (например, для совместного перемещения группы объектов), следует использовать один и тот же <b>объект</b> <b>компонента</b>.</dd></dl>
<p>Разные объекты могут использовать рендеры, выполняющие одно и то же действие, в этом случае для экономии ресурсов можно создать эти рендеры (один раз) заранее, а дальнейшем использовать их через компоненты с соответствующими id.</p>
<h2>Камера и настройки конвеера рендеринга </h2>
<dl class="section note"><dt>Заметки</dt><dd>Здесь и далее все создаваемые наборы рендеров добавляются в общий набор объектов, а <b>сцена</b> представляет собой список идентификаторов объектов в этом наборе.</dd></dl>
<p>В данном примере формируется объект, состоящий из рендеров:</p><ul>
<li>Компонент точки в пространстве, в которую 'смотрит' камера.</li>
<li>Перспективной камеры.</li>
<li>Рендера, очищающего задний буфер и заливающего его указанным цаетом.</li>
<li>Рендера, включающего использование буфера глубины и очищающего его.</li>
<li>Рендера настроек использования текстуры.</li>
</ul>
<div class="fragment"><div class="line">  m_Objects[Id] = m_pRenders-&gt;Obtain(</div><div class="line">    {</div><div class="line">      Component_t::Make(</div><div class="line">      {</div><div class="line">        { uT(<span class="stringliteral">&quot;type&quot;</span>), uT(<span class="stringliteral">&quot;Data&quot;</span>) },</div><div class="line">        { uT(<span class="stringliteral">&quot;kind&quot;</span>), uT(<span class="stringliteral">&quot;Position&quot;</span>) },</div><div class="line">        { uT(<span class="stringliteral">&quot;x&quot;</span>), 0.0f },</div><div class="line">        { uT(<span class="stringliteral">&quot;y&quot;</span>), 0.0f },</div><div class="line">        { uT(<span class="stringliteral">&quot;z&quot;</span>), -1.6f },</div><div class="line">      }),</div><div class="line">      Component_t::Make(</div><div class="line">      {</div><div class="line">        { uT(<span class="stringliteral">&quot;id&quot;</span>), uT(<span class="stringliteral">&quot;Example.Camera.&quot;</span>) + Id.GetStringId() },</div><div class="line">        { uT(<span class="stringliteral">&quot;type&quot;</span>), uT(<span class="stringliteral">&quot;Camera&quot;</span>) },</div><div class="line">        { uT(<span class="stringliteral">&quot;kind&quot;</span>), uT(<span class="stringliteral">&quot;Perspective&quot;</span>) },</div><div class="line">        { uT(<span class="stringliteral">&quot;distance&quot;</span>), 10.0f },</div><div class="line">        { uT(<span class="stringliteral">&quot;fov&quot;</span>), 90.0f },</div><div class="line">      }),</div><div class="line">      Component_t::Make(</div><div class="line">      {</div><div class="line">        { uT(<span class="stringliteral">&quot;id&quot;</span>), uT(<span class="stringliteral">&quot;Example.State.Clear&quot;</span>) },</div><div class="line">        { uT(<span class="stringliteral">&quot;type&quot;</span>), uT(<span class="stringliteral">&quot;State&quot;</span>) },</div><div class="line">        { uT(<span class="stringliteral">&quot;kind&quot;</span>), uT(<span class="stringliteral">&quot;Clear&quot;</span>) },</div><div class="line">        { uT(<span class="stringliteral">&quot;color&quot;</span>), 0xFF0000FF },</div><div class="line">      }),</div><div class="line">      Component_t::Make(</div><div class="line">      {</div><div class="line">        { uT(<span class="stringliteral">&quot;id&quot;</span>), uT(<span class="stringliteral">&quot;Example.State.Depth&quot;</span>) },</div><div class="line">        { uT(<span class="stringliteral">&quot;type&quot;</span>), uT(<span class="stringliteral">&quot;State&quot;</span>) },</div><div class="line">        { uT(<span class="stringliteral">&quot;kind&quot;</span>), uT(<span class="stringliteral">&quot;Depth&quot;</span>) },</div><div class="line">        { uT(<span class="stringliteral">&quot;enabled&quot;</span>), <span class="keyword">true</span> },</div><div class="line">        { uT(<span class="stringliteral">&quot;clear&quot;</span>), <span class="keyword">true</span> },</div><div class="line">      }),</div><div class="line">      Component_t::Make(</div><div class="line">      {</div><div class="line">        { uT(<span class="stringliteral">&quot;id&quot;</span>), uT(<span class="stringliteral">&quot;Example.State.Sampler&quot;</span>) },</div><div class="line">        { uT(<span class="stringliteral">&quot;type&quot;</span>), uT(<span class="stringliteral">&quot;State&quot;</span>) },</div><div class="line">        { uT(<span class="stringliteral">&quot;kind&quot;</span>), uT(<span class="stringliteral">&quot;Sampler&quot;</span>) },</div><div class="line">      }),</div><div class="line">      Component_t::Make(</div><div class="line">      {</div><div class="line">        { uT(<span class="stringliteral">&quot;id&quot;</span>), uT(<span class="stringliteral">&quot;Example.Updater.Simple3DObject.&quot;</span>) + Id.GetStringId() },</div><div class="line">        { uT(<span class="stringliteral">&quot;type&quot;</span>), uT(<span class="stringliteral">&quot;Updater&quot;</span>) },</div><div class="line">        { uT(<span class="stringliteral">&quot;function&quot;</span>), GetUpdater() },</div><div class="line">      }),</div><div class="line">    });</div></div><!-- fragment --> <h2>Источники света </h2>
<p>Фоновый и направленный источники света:</p>
<div class="fragment"><div class="line">  <span class="keywordflow">if</span> (IsActive(Lights::Ambient))</div><div class="line">  {</div><div class="line">    Components += Object_t</div><div class="line">    {</div><div class="line">      Component_t::Make(</div><div class="line">      {</div><div class="line">        { uT(<span class="stringliteral">&quot;id&quot;</span>), uT(<span class="stringliteral">&quot;Example.Light.Ambient&quot;</span>) },</div><div class="line">        { uT(<span class="stringliteral">&quot;type&quot;</span>), uT(<span class="stringliteral">&quot;Light&quot;</span>) },</div><div class="line">        { uT(<span class="stringliteral">&quot;kind&quot;</span>), uT(<span class="stringliteral">&quot;Ambient&quot;</span>) },</div><div class="line">        { uT(<span class="stringliteral">&quot;color&quot;</span>), 0xFF303030 }, <span class="comment">// ARGB</span></div><div class="line">      }),</div><div class="line">    };</div><div class="line">  }</div><div class="line">    </div><div class="line">  <span class="keywordflow">if</span> (IsActive(Lights::Directional))</div><div class="line">  {</div><div class="line">    Components += Object_t</div><div class="line">    {</div><div class="line">      Component_t::Make(</div><div class="line">      {</div><div class="line">        { uT(<span class="stringliteral">&quot;type&quot;</span>), uT(<span class="stringliteral">&quot;Data&quot;</span>) },</div><div class="line">        { uT(<span class="stringliteral">&quot;kind&quot;</span>), uT(<span class="stringliteral">&quot;Direction&quot;</span>) },</div><div class="line">        { uT(<span class="stringliteral">&quot;x&quot;</span>), 1.0f },</div><div class="line">        { uT(<span class="stringliteral">&quot;y&quot;</span>), -1.0f },</div><div class="line">        { uT(<span class="stringliteral">&quot;z&quot;</span>), 1.0f },</div><div class="line">      }),</div><div class="line">      Component_t::Make(</div><div class="line">      {</div><div class="line">        { uT(<span class="stringliteral">&quot;id&quot;</span>), uT(<span class="stringliteral">&quot;Example.Light.Direction&quot;</span>) },</div><div class="line">        { uT(<span class="stringliteral">&quot;type&quot;</span>), uT(<span class="stringliteral">&quot;Light&quot;</span>) },</div><div class="line">        { uT(<span class="stringliteral">&quot;kind&quot;</span>), uT(<span class="stringliteral">&quot;Direction&quot;</span>) },</div><div class="line">        { uT(<span class="stringliteral">&quot;color&quot;</span>), 0xFF808080 }, <span class="comment">// ARGB</span></div><div class="line">      }),</div><div class="line">    };</div><div class="line">  }</div></div><!-- fragment --> <h2>Рендеринг объектов </h2>
<p>Объект, отображаемый на экране, представляет собой набор рендеров, который создается на основе набора компонентов и должен включать:</p><ul>
<li>Вершинный шейдер.</li>
<li>Пиксельный шейдер.</li>
<li>Текстуру.</li>
<li>Вертексный буфер.</li>
<li>Индексный буфер.</li>
<li>Компоненты положения/ориентации/масштабирования (не обязательны).</li>
<li>Present.Geometry (именно он осуществляет отрисовку объекта, поэтому должен располагаться последним).</li>
</ul>
<p>Поскольку для различных реализаций (OpenGL или DirectX) требуются шейдеры в разных форматах, для обеспечения кроссплатформенности кода необходимо предоставить шейдеры для всех поддерживаемых реализаций (например, для DirectX используется компонент Data.Shader.HLSL); не подходящие для текущего графического Api будут проигнорированы при создании рендеров.</p>
<p>Компоненты Data.Position/Data.Rotation/Data.Scale используются для перемещения/вращения/изменения размеров объектов без их пересоздания (достаточно установить новые значения параметров при обновлении сцены), причем:</p><ul>
<li>Компонентов одного типа может быть несколько (что позволяет, например, создавать группы объектов, которые должны быть расположены относительно друг друга определенным образом, но при этом двигаться/вращаться вместе; во втором случае необходимо использовать общий <b>объект</b> <b>компонента</b>, использование разных объектов с одинаковым <b>id</b> нужного эффекта не даст).</li>
<li>Важен порядок следования компонентов (поворот-перемещение даст сначала поворот вокруг точки [0, 0, 0] с нулевым радиусом, а затем уже смещение повернутого объекта, а перемещение-поворот даст сначала смещение от точки [0, 0, 0], а затем уже поворот вокруг нее с радиусом смещения).</li>
</ul>
<dl class="todo"><dt><b><a class="el" href="a34064.html#_todo000002">Необходимо сделать:</a></b></dt><dd><ul>
<li>Добавить картинку, объясняющую разницу между поворот-смещение и смещение-поворот.</li>
</ul>
</dd></dl>
<h3>Текстурированный объект</h3>
<p>Текстуры, которые будут использоваться, можно подгрузить заранее, чтобы потом ссылаться на них по их идентификатору.</p>
<div class="fragment"><div class="line">  <span class="keyword">const</span> image::Universal_t&lt;image::pixel::RGBA&gt; Image</div><div class="line">  {</div><div class="line">    ::covellite::gui::Vfs_t::GetInstance().GetData(</div><div class="line">      PathToTextureDirectory / _RelativePathToSourceFile)</div><div class="line">  };</div><div class="line">    </div><div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> Renders = m_pRenders-&gt;Obtain(</div><div class="line">    {</div><div class="line">      Component_t::Make(</div><div class="line">      {</div><div class="line">        { uT(<span class="stringliteral">&quot;type&quot;</span>), uT(<span class="stringliteral">&quot;Data&quot;</span>) },</div><div class="line">        { uT(<span class="stringliteral">&quot;kind&quot;</span>), uT(<span class="stringliteral">&quot;Texture&quot;</span>) },</div><div class="line">        { uT(<span class="stringliteral">&quot;data&quot;</span>), Image.GetData().Buffer.data() },</div><div class="line">        { uT(<span class="stringliteral">&quot;width&quot;</span>), static_cast&lt;int&gt;(Image.GetData().Width) },</div><div class="line">        { uT(<span class="stringliteral">&quot;height&quot;</span>), static_cast&lt;int&gt;(Image.GetData().Height) },</div><div class="line">      }),</div><div class="line">      Component_t::Make(</div><div class="line">      {</div><div class="line">        { uT(<span class="stringliteral">&quot;id&quot;</span>), _TextureId },</div><div class="line">        { uT(<span class="stringliteral">&quot;type&quot;</span>), uT(<span class="stringliteral">&quot;Texture&quot;</span>) },</div><div class="line">      }),</div><div class="line">    });</div><div class="line">    </div><div class="line">  ::boost::ignore_unused(Renders);</div></div><!-- fragment --><p> Пример формирования текстурированного объекта; по порядку:</p><ul>
<li>Вертексный шейдер для отрисовки текстурированных объектов, использующий шейдер по умолчанию.</li>
<li>Пиксельный шейдер для отрисовки объектов c текстурой, использующий шейдер по умолчанию.</li>
<li>Материал поверхности.</li>
<li>Текстура (создана ранее).</li>
<li>Вертексный буфер, содержащий уникальные для данного объекта данные вершин.</li>
<li>Индексный буфер, содержащий уникальные для данного объекта данные вершин.</li>
<li>Компонент масштабирования.</li>
<li>Компонент вращения (создан заранее, что можно было обновлять его значения перед отрисовкой каждого кадра).</li>
<li>Компонент смещения.</li>
<li>Компонент отрисовки объекта.</li>
</ul>
<div class="fragment"><div class="line">  m_Objects[Id] = m_pRenders-&gt;Obtain(</div><div class="line">    {</div><div class="line">      Component_t::Make(</div><div class="line">      {</div><div class="line">        { uT(<span class="stringliteral">&quot;type&quot;</span>), uT(<span class="stringliteral">&quot;Data&quot;</span>) },</div><div class="line">        { uT(<span class="stringliteral">&quot;kind&quot;</span>), uT(<span class="stringliteral">&quot;Shader.HLSL&quot;</span>) },</div><div class="line">        { uT(<span class="stringliteral">&quot;version&quot;</span>), uT(<span class="stringliteral">&quot;vs_4_0&quot;</span>) },</div><div class="line">        { uT(<span class="stringliteral">&quot;entry&quot;</span>), uT(<span class="stringliteral">&quot;vsTextured&quot;</span>) },</div><div class="line">      }),</div><div class="line">      Component_t::Make(</div><div class="line">      {</div><div class="line">        { uT(<span class="stringliteral">&quot;id&quot;</span>), uT(<span class="stringliteral">&quot;Example.Shader.Vertex.Cube&quot;</span>) },</div><div class="line">        { uT(<span class="stringliteral">&quot;type&quot;</span>), uT(<span class="stringliteral">&quot;Shader&quot;</span>) },</div><div class="line">      }),</div><div class="line">      Component_t::Make(</div><div class="line">      {</div><div class="line">        { uT(<span class="stringliteral">&quot;type&quot;</span>), uT(<span class="stringliteral">&quot;Data&quot;</span>) },</div><div class="line">        { uT(<span class="stringliteral">&quot;kind&quot;</span>), uT(<span class="stringliteral">&quot;Shader.HLSL&quot;</span>) },</div><div class="line">        { uT(<span class="stringliteral">&quot;version&quot;</span>), uT(<span class="stringliteral">&quot;ps_4_0&quot;</span>) },</div><div class="line">        { uT(<span class="stringliteral">&quot;entry&quot;</span>), uT(<span class="stringliteral">&quot;psTextured&quot;</span>) },</div><div class="line">      }),</div><div class="line">      Component_t::Make(</div><div class="line">      {</div><div class="line">        { uT(<span class="stringliteral">&quot;id&quot;</span>), uT(<span class="stringliteral">&quot;Example.Shader.Pixel.Cube&quot;</span>) },</div><div class="line">        { uT(<span class="stringliteral">&quot;type&quot;</span>), uT(<span class="stringliteral">&quot;Shader&quot;</span>) },</div><div class="line">      }),</div><div class="line">      Component_t::Make(</div><div class="line">      {</div><div class="line">        { uT(<span class="stringliteral">&quot;id&quot;</span>), uT(<span class="stringliteral">&quot;Example.Material.Cube&quot;</span>) },</div><div class="line">        { uT(<span class="stringliteral">&quot;type&quot;</span>), uT(<span class="stringliteral">&quot;Material&quot;</span>) },</div><div class="line">        { uT(<span class="stringliteral">&quot;ambient&quot;</span>), 0xFFFFFFFF },</div><div class="line">        { uT(<span class="stringliteral">&quot;diffuse&quot;</span>), 0xFFFFFFFF },</div><div class="line">      }),</div><div class="line">      Component_t::Make(</div><div class="line">      {</div><div class="line">        { uT(<span class="stringliteral">&quot;id&quot;</span>), uT(<span class="stringliteral">&quot;Example.Texture&quot;</span>) },</div><div class="line">      }),</div><div class="line">      Component_t::Make(</div><div class="line">      {</div><div class="line">        { uT(<span class="stringliteral">&quot;id&quot;</span>), uT(<span class="stringliteral">&quot;Example.Buffer.Vertex.Cube&quot;</span>) },</div><div class="line">        { uT(<span class="stringliteral">&quot;type&quot;</span>), uT(<span class="stringliteral">&quot;Buffer&quot;</span>) },</div><div class="line">        { uT(<span class="stringliteral">&quot;data&quot;</span>), VertexData.data() },</div><div class="line">        { uT(<span class="stringliteral">&quot;count&quot;</span>), VertexData.size() },</div><div class="line">      }),</div><div class="line">      Component_t::Make(</div><div class="line">      {</div><div class="line">        { uT(<span class="stringliteral">&quot;id&quot;</span>), uT(<span class="stringliteral">&quot;Example.Buffer.Index.Cube.&quot;</span>) + Id.GetStringId() },</div><div class="line">        { uT(<span class="stringliteral">&quot;type&quot;</span>), uT(<span class="stringliteral">&quot;Buffer&quot;</span>) },</div><div class="line">        { uT(<span class="stringliteral">&quot;kind&quot;</span>), uT(<span class="stringliteral">&quot;Index&quot;</span>) },</div><div class="line">        { uT(<span class="stringliteral">&quot;data&quot;</span>), (<span class="keyword">const</span> <span class="keywordtype">int</span> *)IndexData.data() },</div><div class="line">        { uT(<span class="stringliteral">&quot;count&quot;</span>), IndexData.size() },</div><div class="line">      }),</div><div class="line">      Component_t::Make(</div><div class="line">      {</div><div class="line">        { uT(<span class="stringliteral">&quot;type&quot;</span>), uT(<span class="stringliteral">&quot;Data&quot;</span>) },</div><div class="line">        { uT(<span class="stringliteral">&quot;kind&quot;</span>), uT(<span class="stringliteral">&quot;Scale&quot;</span>) },</div><div class="line">        { uT(<span class="stringliteral">&quot;x&quot;</span>), _Scale },</div><div class="line">        { uT(<span class="stringliteral">&quot;y&quot;</span>), _Scale },</div><div class="line">        { uT(<span class="stringliteral">&quot;z&quot;</span>), _Scale },</div><div class="line">      }),</div><div class="line">      m_pCubeRotation,</div><div class="line">      Component_t::Make(</div><div class="line">      {</div><div class="line">        { uT(<span class="stringliteral">&quot;type&quot;</span>), uT(<span class="stringliteral">&quot;Data&quot;</span>) },</div><div class="line">        { uT(<span class="stringliteral">&quot;kind&quot;</span>), uT(<span class="stringliteral">&quot;Position&quot;</span>) },</div><div class="line">        { uT(<span class="stringliteral">&quot;x&quot;</span>), 0.0f },</div><div class="line">        { uT(<span class="stringliteral">&quot;y&quot;</span>), -_PositionX },</div><div class="line">        { uT(<span class="stringliteral">&quot;z&quot;</span>), _PositionY },</div><div class="line">      }),</div><div class="line">      Component_t::Make(</div><div class="line">      {</div><div class="line">        { uT(<span class="stringliteral">&quot;id&quot;</span>), uT(<span class="stringliteral">&quot;Example.Present.Geometry.&quot;</span>) + Id.GetStringId() },</div><div class="line">        { uT(<span class="stringliteral">&quot;type&quot;</span>), uT(<span class="stringliteral">&quot;Present&quot;</span>) },</div><div class="line">        { uT(<span class="stringliteral">&quot;kind&quot;</span>), uT(<span class="stringliteral">&quot;Geometry&quot;</span>) },</div><div class="line">      })</div><div class="line">    });</div></div><!-- fragment --> <dl class="section note"><dt>Заметки</dt><dd><ul>
<li>Можно использовать текстуру, содержащую несколько изображений для разных объектов, но при этом все равно необходимо устанавливать компонент этой текстуры <b>каждому</b> объекту, т.к. Present.Geometry отключает использование текстур после отрисовки объекта.</li>
</ul>
</dd></dl>
<h3>Скайбокс</h3>
<p>Для отрисовки скайбокса необходимо сформировать отдельную сцену, содержащую компоненты:</p><ul>
<li>Камеры, которая 'смотрит' в начало координат с нулевой дистанции и вращается синхронно с камерой, привязанной к персонажу, управляемому игроком.</li>
<li>Компонента, отключающего использование буфер глубины.</li>
<li>Фоновый источник света и материал белого цвета (0xFFFFFFFF).</li>
<li>Шейдеры, текстуру и куб в начале координат, вертексный буфер которого сформирован таким образом, чтобы отрисовывались его внутренние поверхности.</li>
</ul>
<h1>Подготовка 3D модели </h1>
<dl class="section warning"><dt>Предупреждения</dt><dd>Visual Studio умеет отображать и редактировать 3D модели (форматы .obj, .dae и .fbx), но при сохранении результата в файл .obj он сохраняется как utf8 <b>без</b> <b>сигнатуры</b>, после чего при повторном открытии этого файла он открывается как текстовый файл. Чтобы Visual Studio открыл его в 3D редакторе, необходимо пересохранить файл как utf8 <b>с</b> <b>сигнатурой</b>.</dd></dl>
<p>При подготовке файла 3D модели к использованию фреймворком возможны следующие действия:</p>
<h3>Триангуляция</h3>
<p>3D редактор Visual Studio:</p>
<div class="image">
<img src="Triangulation.png" alt="Triangulation.png"/>
</div>
<h3>Перенос/поворот/масштабирование модели</h3>
<p>3D редактор Visual Studio:</p>
<div class="image">
<img src="Transformation.png" alt="Transformation.png"/>
</div>
<h3>Объединение нескольких текстур в одну</h3>
<p>Фреймворк поддерживает использование только одной текстуры для одной модели (модель = вертексный + индексный буфер), поэтому для файлов, содержащих несколько отдельных моделей, каждой из которых задана своя текстура, необходимо произвести объединение мешей (это делает 3D редактор Visual Studio) и текстур (например, при помощи GIMP). Проблема заключается в том, что у 3D модели необходимо модифицировать текстурные координаты таким образом, чтобы она правильно отображалась с объединенной текстурой.</p>
<p>При помощи Blender'а это можно сделать так:</p><ul>
<li>Открываем файл 3D модели и переключаемся в режим редактирования текстурных координат.</li>
</ul>
<div class="image">
<img src="UVImageEditor.png" alt="UVImageEditor.png"/>
</div>
<ul>
<li>Для материала каждой модели - выбираем его, наводим курсор на поле развертки и нажимаем A, чтобы выделить всю развертку целиком.</li>
</ul>
<div class="image">
<img src="SelectAll.png" alt="SelectAll.png"/>
</div>
<ul>
<li>Для изменения масштаба нажимаем S (после чего X или Y, если масштабирование требуется только по одной оси) и, перемещая мышь, изменяем размер развертки до требуемого (с зажатым Ctrl - с шагом 0.1).</li>
</ul>
<div class="image">
<img src="ScaleX.png" alt="ScaleX.png"/>
</div>
<ul>
<li>Для перемещения нажимаем G и, перемещая мышь, перемещаем развертку в нужное место текстуры (с зажатым Ctrl - с шагом 1/8 размера текстуры).</li>
</ul>
<div class="image">
<img src="Translate.png" alt="Translate.png"/>
</div>
<ul>
<li>После экспорта результата модель будет использовать новые текстурные координаты. </li>
</ul>
</div></div><!-- PageDoc -->
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="index.html">notitle</a></li><li class="navelem"><a class="el" href="a35494.html">Manual</a></li>
    <li class="footer">Документация по Covellite++. Последние изменения: Чт 9 Май 2019 14:51:04. Создано системой
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.15 </li>
  </ul>
</div>
</body>
</html>

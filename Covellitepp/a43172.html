<!-- HTML header for doxygen 1.8.15-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-151583584-1"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag() { dataLayer.push(arguments); }
        gtag('js', new Date());
        gtag('config', 'UA-151583584-1');
    </script>
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=9" />
    <meta name="generator" content="Doxygen 1.8.18" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Covellite++: Компонентная система</title>
    <link href="tabs.css" rel="stylesheet" type="text/css" />
    <script type="text/javascript" src="jquery.js"></script>
    <script type="text/javascript" src="dynsections.js"></script>
    <link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
    <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
    <link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="Title.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Covellite++
   &#160;<span id="projectnumber">Version: 2.2.5 Revision: 2280 Platform: x64 Build: 23:17 28.05.2020</span>
   </div>
   <div id="projectbrief">Кроссплатформенный фреймворк для разработки приложений на С++</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Создано системой Doxygen 1.8.18 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Поиск');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Поиск');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('a43172.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Компонентная система </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1>Используемые термины </h1>
<ul>
<li><b>Компонент</b> - объект, содержащий информацию об одном аспекте игрового объекта (таких как текстура, меш, положение и т.п.).</li>
</ul>
<p><b>Игровой</b> <b>объект</b> - объект в игровом мире, содержащий информацию в виде набора компонентов.</p><ul>
<li><b>Игровой</b> <b>мир</b> - набор игровых объектов, разбитый на иерархическую структуру из ячеек, каждая из которых содержит несколько игровых объектов; назначение - оптимизация подгрузки и выгрузки игровых объектов (сразу ячейками).</li>
<li><b>Игровая</b> <b>сцена</b> - набор игровых объектов, непосредственно участвующих в игровом процессе; объекты подгружаются (по мере необходимости) из игрового мира и это именно те объекты, которые должны обновляться в процессе игры.</li>
<li><b>Рендер</b> - объект, предназначенный для отображения игровых объектов в 3D сцене, создается на основе одного или нескольких компонентов.</li>
<li><b>Объект</b> <b>3D</b> <b>сцены</b> - объект (набор рендеров), из которых состоит 3D сцена.</li>
<li><b>3D</b> <b>сцена</b> - набор объектов 3D сцены, которые отображаются в окне программы; является 'зеркалом' той части объектов игровой сцены, которые попадают в поле зрения камеры.</li>
</ul>
<h1>Исходные требования </h1>
<ul>
<li>Не должно производиться никаких лишних действий (вызовов пустых функций), для каждого объекта (игрового и 3D сцены) должен выполнятся набор только ему необходимых действий.</li>
<li>Отсутствие дублирования информации (все объекты, отрисовываемые при помощи одного меша, должны содержать ссылку на единую область памяти с информацией об этом меше).</li>
</ul>
<h1>Компоненты </h1>
<p>Фреймворк предоставляет класс компонента <a class="el" href="a41594.html">Component</a>, а также механизм создания рендеров для этих компонентов с учетом активного графического Api (рендеры создаются через объект класса <a class="el" href="a41950.html">Renders</a>, который может быть получен при помощи функции GetRenders() класса <a class="el" href="a41974.html">Window</a>).</p>
<p>Класс компонента:</p><ul>
<li>Содержит и предоставляет доступ к параметрам, которые используются для создания рендеров.</li>
<li>Параметры (кроме обязательных) могут отсутствовать, для таких параметров предусмотрено значение по умолчанию.</li>
<li>Обязательный параметр <b>id</b> - идентификатор компонента. Для компонентов с одним и тем же идентификатором будет использоваться один и тот же рендер, поэтому объекты, содержащие один и тот же меш, могут содержать компоненты, у которых задан только (один и тот же) идентификатор, а развернутое описание этого компонента можно сделать в другом месте и создать его рендер заранее.</li>
<li>Обязательный параметр <b>type</b> - тип компонента, который определяет способ отрисовки этого компонента.</li>
<li>Параметр <b>kind</b> - дочерний подтип компонента; у некоторых типов не используется.</li>
<li>Первоначальная информация может загружаться в виде строк, в дальнейшем (для ускорения рендеринга) при обновлении игровых объектов значения параметров следует устанавливать того же типа, какой используют рендеры (подробнее см. в описании параметорв компонентов).</li>
</ul>
<dl class="section note"><dt>Заметки</dt><dd>Предполагается, что исходная информация о компоненте будет хранится в узлах xml файла, из которых параметры будут загружаться как атрибуты, у которых имя атрибута будет названием параметра, а значение атрибута - значением параметра.</dd></dl>
<h2>Типы компонентов </h2>
<h3>Data</h3>
<p>Вспомогательный компонент, предназначенный для передачи информации рендерам других типов.</p>
<dl class="section note"><dt>Заметки</dt><dd><ul>
<li>Для этого компонента не создается рендера, вместо этого он захватывается и используется следующим рендером, который будет создан (какие данные нужны конкретным рендерам см. в описании соответствующих компонентов).</li>
<li>Идентификатор этого компонента не используется.</li>
</ul>
</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">kind </th><th class="markdownTableHeadNone">Параметры </th><th class="markdownTableHeadNone">Тип параметра (значение по умолчанию) </th><th class="markdownTableHeadNone">Описание параметра  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Position (<a class="el" href="a43172.html#Footnote">1</a>) </td><td class="markdownTableBodyNone">x, y, z </td><td class="markdownTableBodyNone">float (0.0f) </td><td class="markdownTableBodyNone">Положение (координаты) в пространстве  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Rotation (<a class="el" href="a43172.html#Footnote">1</a>) </td><td class="markdownTableBodyNone">x, y, z </td><td class="markdownTableBodyNone">float (0.0f) </td><td class="markdownTableBodyNone">Ориентация (углы поворота вокруг соответствующей оси в радианах) в пространстве  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Scale (<a class="el" href="a43172.html#Footnote">1</a>) </td><td class="markdownTableBodyNone">x, y, z </td><td class="markdownTableBodyNone">float (1.0f) </td><td class="markdownTableBodyNone">Масштабирующие коэффициенты по соответствующим осям  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Rect (<a class="el" href="a43172.html#Footnote">1</a>) </td><td class="markdownTableBodyNone">left, top, right, bottom </td><td class="markdownTableBodyNone">int </td><td class="markdownTableBodyNone">Границы прямоугольника  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone" rowspan="6">Texture </td><td class="markdownTableBodyNone">data </td><td class="markdownTableBodyNone">const uint8_t * </td><td class="markdownTableBodyNone">Бинарные данные текстуры в формате R8G8B8A8  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">width </td><td class="markdownTableBodyNone">int </td><td class="markdownTableBodyNone">Ширина изображения в пикселях  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">height </td><td class="markdownTableBodyNone">int </td><td class="markdownTableBodyNone">Высота изображения в пикселях  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">destination </td><td class="markdownTableBodyNone">String_t (albedo) </td><td class="markdownTableBodyNone">Назначение текстуры (albedo, metalness, roughness, normal, occlusion)  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">mipmapping </td><td class="markdownTableBodyNone">bool (false) </td><td class="markdownTableBodyNone">Генерировать mip'ы для текстуры; только для текстур, не используемых как внеэкранные поверхности  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">mapper </td><td class="markdownTableBodyNone">std::function&lt;bool(const void *)&gt; </td><td class="markdownTableBodyNone">Функция обратного вызова для чтения данных текстуры (каждый пиксель - это число uint32_t в формате ABGR)  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone" rowspan="4">Shader </td><td class="markdownTableBodyNone">data </td><td class="markdownTableBodyNone">const uint8_t * </td><td class="markdownTableBodyNone">Содержимое текстового файла шейдера в бинарном виде  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">count </td><td class="markdownTableBodyNone">size_t </td><td class="markdownTableBodyNone">Размер буфера данных шейдера в байтах  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">entry </td><td class="markdownTableBodyNone">String_t </td><td class="markdownTableBodyNone">Имя функции точки входа шейдера  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">instance </td><td class="markdownTableBodyNone">String_t </td><td class="markdownTableBodyNone">Описатель (вида 'f4f4i4') структуры <a class="el" href="a43173.html">инстанс-буфера</a>  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone" rowspan="5">Buffer </td><td class="markdownTableBodyNone" rowspan="2">data </td><td class="markdownTableBodyNone">const Vertex * </td><td class="markdownTableBodyNone">Данные вертексного буфера для отрисовки плоских объектов (<a class="el" href="a43172.html#Footnote">2</a>)  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">const int * </td><td class="markdownTableBodyNone">Данные индексного буфера  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">count </td><td class="markdownTableBodyNone">size_t </td><td class="markdownTableBodyNone">Количество элементов в буфере, переданном в <b>data</b> или инстанс-буфере  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">mapper </td><td class="markdownTableBodyNone">std::function&lt;bool(void *)&gt; </td><td class="markdownTableBodyNone">Функция обратного вызова для заполнения <a class="el" href="a43173.html">инстанс-буфера</a>  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">size </td><td class="markdownTableBodyNone">size_t </td><td class="markdownTableBodyNone">Размер <a class="el" href="a43173.html">инстанс-буфера</a> в байтах  </td></tr>
</table>
<dl class="deprecated"><dt><b><a class="el" href="a41445.html#_deprecated000001">Уст.:</a></b></dt><dd>Следующие компоненты передачи данных устарели и будут удалены в следующей стабильной версии.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">kind </th><th class="markdownTableHeadNone">Параметры </th><th class="markdownTableHeadNone">Тип параметра </th><th class="markdownTableHeadNone">Описание параметра  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Direction (<a class="el" href="a43172.html#Footnote">1</a>) </td><td class="markdownTableBodyNone">x, y, z </td><td class="markdownTableBodyNone">float </td><td class="markdownTableBodyNone">Вектор направления (из указанной точки в начало координат) в пространстве  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Attenuation (<a class="el" href="a43172.html#Footnote">1</a>) </td><td class="markdownTableBodyNone">const, linear, exponent </td><td class="markdownTableBodyNone">float </td><td class="markdownTableBodyNone">Настройки затухания для точечного источника света  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone" rowspan="3">Buffer </td><td class="markdownTableBodyNone" rowspan="2">data </td><td class="markdownTableBodyNone">const <a class="el" href="a41954.html">Vertex::Polygon</a> * </td><td class="markdownTableBodyNone">Данные вертексного буфера для отрисовки плоских объектов (<a class="el" href="a43172.html#Footnote">2</a>)  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">const <a class="el" href="a41958.html">Vertex::Polyhedron</a> * </td><td class="markdownTableBodyNone">Данные вертексного буфера для отрисовки объемных объектов  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">dimension </td><td class="markdownTableBodyNone">int </td><td class="markdownTableBodyNone">2 или 3 (по умолчанию) - размерность отрисовываемого объекта  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone" rowspan="3">Fog </td><td class="markdownTableBodyNone">color </td><td class="markdownTableBodyNone">uint32_t (0xFFFFFFFF) </td><td class="markdownTableBodyNone">Цвет тумана в формате ARGB  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">near, far </td><td class="markdownTableBodyNone">float </td><td class="markdownTableBodyNone">Расстояния до передней и задней дистанции при расчете тумана (нужны для linear)  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">density </td><td class="markdownTableBodyNone">float </td><td class="markdownTableBodyNone">Коэффициент, определяющий скорость возрастания плотности тумана (нужен для exp и exp2)  </td></tr>
</table>
<dl class="section note"><dt>Заметки</dt><dd>Параметр <b>dimension</b> для вертексного буфера имеет смысл только для формата вершин <a class="el" href="a41962.html">Vertex</a> и реализаций со статическим конвеером для указания того, как следует интерпретировать данные вертексного буфера - 2D или 3D объекты; шейдерные реализации просто передают буфер шейдеру и поэтому следует устанавливать шейдер, который будет правильно использовать переданные данные.</dd></dl>
<h3>Camera</h3>
<p>Компонент виртуальной камеры.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">kind </th><th class="markdownTableHeadNone">Требуется Data (kind) </th><th class="markdownTableHeadNone">Параметры </th><th class="markdownTableHeadNone">Тип параметра (значение по умолчанию) </th><th class="markdownTableHeadNone">Описание параметра  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Orthographic </td><td class="markdownTableBodyNone">Position </td><td class="markdownTableBodyNone">- </td><td class="markdownTableBodyNone">- </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone" rowspan="4">Perspective </td><td class="markdownTableBodyNone" rowspan="4">Position, Rotation </td><td class="markdownTableBodyNone">distance </td><td class="markdownTableBodyNone">float (0.0f) </td><td class="markdownTableBodyNone">Расстояние от позиции, заданной компонентом Data.Position до камеры  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">fov </td><td class="markdownTableBodyNone">float (90.0f) </td><td class="markdownTableBodyNone">Угол поля зрения по вертикали в градусах  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">znear </td><td class="markdownTableBodyNone">float (0.01f) </td><td class="markdownTableBodyNone">Ближняя плоскость отсечения  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">zfar </td><td class="markdownTableBodyNone">float (200.0f) </td><td class="markdownTableBodyNone">Дальняя плоскость отсечения  </td></tr>
</table>
<dl class="section note"><dt>Заметки</dt><dd><ul>
<li>Камера определяет способ отрисовки сцены и ее рендер должен быть первым в списке 3D сцены.</li>
<li>Компонент формирует матрицы вида/проекции и передает их шейдеру (константный буфер шейдера <b>CameraData</b>).</li>
<li>Сформированные матрицы вида/проекции после вызова рендера будут записаны исходному объекту компонента камеры как параметры <b>view</b> и <b>projection</b> в виде объекта класса glm::mat4 (матрицы записываются в том же виде, что и при передаче шейдеру, т.е. транспонированными).</li>
</ul>
</dd></dl>
<hr  />
<p><b>Ортографическа</b> камера использует левостороннюю систему координат, в которой:</p><ul>
<li>Начало координат находится в левом верхнем углу экрана (viewport'ом в Windows является вся клиентская часть окна, в Android - все за исключением заголовка окна).</li>
<li>Координаты вдоль оси X увеличиваются вправо.</li>
<li>Координаты вдоль оси Y увеличиваются вниз.</li>
<li>Камера смотрит на плоскость Oxy со стороны положительных значений оси Z.</li>
<li>Одному пикселю окна программы соответствует изменение координаты на 1.0f.</li>
</ul>
<dl class="todo"><dt><b><a class="el" href="a41444.html#_todo000004">Необходимо сделать:</a></b></dt><dd><ul>
<li>Добавить картинку с осями координат для Windows и Android.</li>
</ul>
</dd></dl>
<p><b>Перспективная</b> камера использует правостороннюю систему координат:</p><ul>
<li>Координаты вдоль оси X увеличиваются с запада на восток.</li>
<li>Координаты вдоль оси Y увеличиваются с юга на север.</li>
<li>Координаты вдоль оси Z (высота над плоскостью Oxy) увеливаются снизу вверх.</li>
<li>Камера смотрит в точку, заданную компонентом Data.Position с расстояния <b>distance</b> (т.е. реализован вид 'от третьего лица', если нужен вид 'от первого лица', установить distance в ноль).</li>
<li>Data.Rotation - это углы поворота самой камеры относительно точки Data.Position (т.е. направление, <b>обратное</b> направлению взгляда).</li>
<li>Отсутствие компонента Data.Rotation (нулевые значения углов ориентации) соответствует направлению взгляда из точки, смещенной от Data.Position на distance вдоль оси X в положительном направлении.</li>
</ul>
<h3>BkSurface</h3>
<p>Компонент внеэкранной поверхности, предназначен для рендеринга в текстуру(ы).</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">kind </th><th class="markdownTableHeadNone">Требуется Data (kind) </th><th class="markdownTableHeadNone">Параметры </th><th class="markdownTableHeadNone">Тип параметра </th><th class="markdownTableHeadNone">Описание параметра  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">- </td><td class="markdownTableBodyNone">Texture </td><td class="markdownTableBodyNone">- </td><td class="markdownTableBodyNone">- </td><td class="markdownTableBodyNone"></td></tr>
</table>
<p>Подробнее о использовании компонента см. <a class="el" href="a43170.html">Рендеринг во внеэкранную поверхность</a>.</p>
<h3>State</h3>
<p>Компонент изменения состояния конвеера рендеринга.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">kind </th><th class="markdownTableHeadNone">Требуется Data (kind) </th><th class="markdownTableHeadNone">Параметры </th><th class="markdownTableHeadNone">Тип параметра </th><th class="markdownTableHeadNone">Описание параметра  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Clear </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">color </td><td class="markdownTableBodyNone">uint32_t </td><td class="markdownTableBodyNone">Цвет заливки буфера кадра  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone" rowspan="3">Depth </td><td class="markdownTableBodyNone" rowspan="3"></td><td class="markdownTableBodyNone">enabled </td><td class="markdownTableBodyNone">bool (false) </td><td class="markdownTableBodyNone">Включение/отключение использования буфера глубины (используется инвертировааный буфер глубины)  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">clear </td><td class="markdownTableBodyNone">bool (false) </td><td class="markdownTableBodyNone">Включение/отключение очистки буфера глубины  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">overwrite </td><td class="markdownTableBodyNone">bool (true) </td><td class="markdownTableBodyNone">Включение/отключение перезаписи буфера глубины  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Blend </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">Включение использования прозрачности  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Sampler </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">Включение использования сглаживания текстур  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Scissor </td><td class="markdownTableBodyNone">Rect </td><td class="markdownTableBodyNone">enabled </td><td class="markdownTableBodyNone">bool </td><td class="markdownTableBodyNone">В случае false Data.Rect не нужен  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">AlphaTest </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">discard </td><td class="markdownTableBodyNone">float </td><td class="markdownTableBodyNone">Отбрасывание значений цвета, у которых значение Alpha-канала меньше или равно указанному  </td></tr>
</table>
<dl class="section note"><dt>Заметки</dt><dd>Каждая камера при рендеринге отключает:<ul>
<li>Использование внеэкранной поверхности (устаналивает вывод нап экран).</li>
<li>Использование буфера глубины.</li>
<li>Блендинг.</li>
<li>Alpha test (компонент имеет смысл только для реализаций со статическим конвеером; реализации, которые используют шейдеры, должны делать это при помощи шейдера).</li>
</ul>
</dd></dl>
<h3>Shader</h3>
<p>Компонент шейдера.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">kind </th><th class="markdownTableHeadNone">Требуется Data (kind)  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">- </td><td class="markdownTableBodyNone">Shader (<a class="el" href="a43172.html#Footnote">3</a>)  </td></tr>
</table>
<dl class="section note"><dt>Заметки</dt><dd><ul>
<li>Тип создаваемого шейдера (вертексный или пиксельный) выводится автоматически из входного типа данных указанной функции точки входа.</li>
<li>Всем шейдерам в качестве заголовочных файлов передаются:<ul>
<li>Файл, содержащий описания структур для передачи данных шейдеру (<a class="el" href="a41449.html">Fx</a>).</li>
<li>Файл, содержащий описания форматов входных данных шейдеров</li>
</ul>
</li>
<li>Если не указаны бинарные данные шейдера (параметры <b>data</b> и <b>count</b>), вместо них будут использоваться шейдеры по умолчанию (те, что использует фреймворк для рендеринга Gui).</li>
<li>В том случае, если в тексте шейдера содержится ошибка, рендер не будет создан и попытка отрендерить объект без установленного шейдера может привести к падению видеодрайвера. Поэтому хорошей практикой является установка объекту камеры компонентов шейдеров по умолчанию (без передачи данных шейдера <b>data</b> и <b>count</b>), которые в этом случае позволят отрендерить объект 'абы как'.</li>
</ul>
</dd></dl>
<p>Подробнее о том, как формируется окончательный текст шейдера, передаваемый компилятору, см. <a class="el" href="a43176.html">Шейдеры</a>.</p>
<h3>Texture</h3>
<p>Компонент текстуры.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">kind </th><th class="markdownTableHeadNone">Требуется Data (kind)  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">- </td><td class="markdownTableBodyNone">Texture (<a class="el" href="a43172.html#Footnote">3</a>)  </td></tr>
</table>
<dl class="section note"><dt>Заметки</dt><dd><ul>
<li>Реализации со статическим конвеером используют только единственную текстуру (тип можно не указывать), устанавливая ее в нулевой текстурный слот.</li>
<li>Параметр <b>destination</b> компонента данных текстуры предназначен для указания роли текстуры в рамках логики <b>PBR-текстурирования</b>.</li>
<li>В шейдерных реализациях для рендеринга с использованием PBR требуется специальный пиксельный шейдер, т.к. текстуры просто передаются шейдеру в слоты:<ul>
<li>HLSL (<b>albedo</b> - t0, <b>metalness</b> - t1, <b>roughness</b> - t2, <b>normal</b> - t3, <b>occlusion</b> - t4, <b>depth</b> - t5).</li>
<li>GLSL (роль не указана - TexDiffuse, <b>albedo</b> - TexAlbedo, <b>metalness</b> - TexMetalness, <b>roughness</b> - TexRoughness, <b>normal</b> - TexNormal, <b>occlusion</b> - TexOcclusion, <b>depth</b> - TexDepth).</li>
</ul>
</li>
<li>Параметр <b>mapper</b> используется для установки функции обратного вызова, которая вызывается при активации рендера и предназначена для <b>чтения</b> содержимого буфера текстуры (только для текстур, используемых в качестве внеэкранных поверхностей). Нужно понимать, что при этом данные текстуры копируются из видеопамяти в системную память, что является тяжелой операцией и использование ее при каждой активации текстуры (возврат true при каждом вызове функции обратного вызова со значением nullptr) сильно ударит по производительности. Чтение данных из текстуры имеет смысл использовать в качестве особой, разовой операции; например, при обработке клика мышью.</li>
</ul>
</dd></dl>
<h3>Buffer</h3>
<p>Компонент буферов геометрии меша и констант шейдера.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">kind </th><th class="markdownTableHeadNone">Требуется Data (kind) </th><th class="markdownTableHeadNone">Параметры </th><th class="markdownTableHeadNone">Тип параметра </th><th class="markdownTableHeadNone">Описание параметра  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Vertex </td><td class="markdownTableBodyNone" rowspan="4">Buffer (<a class="el" href="a43172.html#Footnote">3</a>) </td><td class="markdownTableBodyNone" rowspan="2">mapper </td><td class="markdownTableBodyNone">std::function&lt;bool(const <a class="el" href="a41962.html">Vertex</a> *)&gt; </td><td class="markdownTableBodyNone">Функция обратного вызова для изменения буфера  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone" rowspan="3">Constant </td><td class="markdownTableBodyNone">std::function&lt;bool(const void *)&gt; </td><td class="markdownTableBodyNone">Функция обратного вызова для заполнения <a class="el" href="a43177.html">пользовательского</a> буфера  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">size </td><td class="markdownTableBodyNone">size_t </td><td class="markdownTableBodyNone">Размер константного буфера в байтах (когда в качестве <b>mapper</b> используется std::function&lt;bool(void *)&gt;)  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">name </td><td class="markdownTableBodyNone">String_t </td><td class="markdownTableBodyNone">Имя переменной <a class="el" href="a43177.html">пользовательского</a> буфера в шейдере ('cbUserData' по умолчанию)  </td></tr>
</table>
<dl class="todo"><dt><b><a class="el" href="a41444.html#_todo000005">Необходимо сделать:</a></b></dt><dd>Требуется обобщение способа передачи параметров константного и инстанс-буфера, т.к. они совпадают, но в первом случае они передаются самому компоненту, а во втором - компоненту Data.Buffer.</dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="a41445.html#_deprecated000002">Уст.:</a></b></dt><dd>Следующие компоненты устарели и будут удалены в следующей стабильной версии, вместо вертексного буфера <a class="el" href="a41958.html">Vertex::Polyhedron</a> следует использовать <a class="el" href="a41962.html">Vertex</a>, вместо индексного буфера - компонент Present.Index, передавая данные ему.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">kind </th><th class="markdownTableHeadNone">Требуется Data (kind) </th><th class="markdownTableHeadNone">Параметры </th><th class="markdownTableHeadNone">Тип параметра </th><th class="markdownTableHeadNone">Описание параметра  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Constant </td><td class="markdownTableBodyNone" rowspan="3">Buffer (<a class="el" href="a43172.html#Footnote">3</a>) </td><td class="markdownTableBodyNone" rowspan="2">mapper </td><td class="markdownTableBodyNone">std::function&lt;bool(const Lights_t *)&gt; </td><td class="markdownTableBodyNone">Функция обратного вызова для формирования списка источников света объекта  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Vertex </td><td class="markdownTableBodyNone">std::function&lt;bool(const <a class="el" href="a41958.html">Vertex::Polyhedron</a> *)&gt; </td><td class="markdownTableBodyNone">Функция обратного вызова для изменения буфера  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Index </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td></tr>
</table>
<dl class="section note"><dt>Заметки</dt><dd><ul>
<li>Параметр <b>kind</b> можно не указывать, тип буфера выводится автоматически из типа переданных ему данных.</li>
<li>Порядок обхода вершин вертексного буфера - против часовой стрелки.</li>
<li>Если передан параметр <b>mapper</b>, будет создан буфер, который можно изменять (только содержимое, причем можно изменять только часть значений; размер буфера, равный значению параметра <b>count</b> изменить нельзя) прямо во время работы программы. Переданный функциональный объект будет вызываться два раза:<ul>
<li>Со значением параметра nullptr - вернуть true или false в зависимости от того, следует ли обновлять буфер или нет.</li>
<li>С указателем на начало памяти буфера, если обновление требуется (возращаемое значение не используется).</li>
</ul>
</li>
<li>Константный буфер для формирования списка источников света объекта в шейдерных реализациях просто сохраняет их во внутренний буфер, после чего они передаются шейдеру вместе с матрицей трансформации объекта (константный буфер шейдера <b>ObjectData.Lights</b>), поэтому этот компонент должен располагаться перед компонентом <b>Transform</b>.</li>
</ul>
</dd></dl>
<hr  />
<p>Логика работы с источниками света через константный буфер с ограниченным количеством слотов для точечных источников света построена исходя из оптимизации расчета освещения каждого объекта (как передача данных, так и расчет освещения для большого количества источников света шейдером очень времязатратная операция, fps катастрофически падает уже при паре десятков источников света в сцене). Сцена может содержать сотни точечных источников света, но здравый смысл подсказывает, что они будут распределены по сцене более-менее равномерно и каждый конкретный объект будет освещен небольшим (единицы) количеством источников света. Поэтому строить набор компонентов объектов сцены имеет смысл следующим образом:</p><ul>
<li>При загрузке сцены все объекты, являющиеся точечными источниками света, добавляют свои параметры в общий список источников света сцены.</li>
<li>Камере добавляется компонент Buffer.Constant, функция обратного вызова которого (<b>mapper</b>) формирует значения фонового и направленного источников света и обнуляет количество слотов точечных источников света.</li>
<li>Каждому объекту сцены добавляется компонент Buffer.Constant, функция обратного вызова которого перебирает список всех точечных источников света и добавляет в список источников света объекта те, которые освещают его сильнее всего (например, самые близкие); максимальное количество - <b>COVELLITE_MAX_LIGHT_POINT_OBJECT_COUNT</b> (если этого количества недостаточно, можно для этой цели использовать <a class="el" href="a43177.html">пользовательский</a> константный буфер).</li>
<li>Расчет радиуса действия для точечного источника света можно посмотреть <a href="https://habr.com/ru/post/420565/">здесь</a>.</li>
<li>Для статичных объектов набор статичных же источников света можно формировать один раз.</li>
</ul>
<h3>Transform</h3>
<p>Компонент установки положения/ориентации/масштабирования объекта.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">kind </th><th class="markdownTableHeadNone">Требуется Data (kind) </th><th class="markdownTableHeadNone">Описание параметра  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">- </td><td class="markdownTableBodyNone" rowspan="2">Position/Rotation/Scale (<a class="el" href="a43172.html#Footnote">4</a>) </td><td class="markdownTableBodyNone">Объект, положение/ориентация/масштаб которого <b>могут</b> изменятся во время работы программы  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Static </td><td class="markdownTableBodyNone">Объект, положение/ориентация/масштаб которого <b>не</b> <b>будут</b> изменятся во время работы программы  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Billboard </td><td class="markdownTableBodyNone">Position (<a class="el" href="a43172.html#Footnote">4</a>) </td><td class="markdownTableBodyNone">Объект, всегда развернутый 'лицом' к камере  </td></tr>
</table>
<dl class="section note"><dt>Заметки</dt><dd><ul>
<li>Компонент формирует матрицу трансформации объекта и передает ее шейдеру (константный буфер шейдера <b>ObjectData.World</b>).</li>
<li>У статического объекта мировая матрица будет вычислена один раз при его создании и в дальнейшем изменить его положение/ориентацию/масштаб будет невозможно; динамический объект захватывает переданные ему компоненты Data, поэтому его положение/ориентацию/масштаб можно менять в каждом кадре изменяя значения параметров этих компонентов.</li>
<li>'Лицом' billboard'a считается плоскость Oxy при взгляде со стороны положительных значений вдоль оси z.</li>
</ul>
</dd></dl>
<h3>Present</h3>
<p>Компонент отправки информации в конвеер рендеринга.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">kind </th><th class="markdownTableHeadNone">Требуется Data (kind)  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Index </td><td class="markdownTableBodyNone">Buffer (<a class="el" href="a43172.html#Footnote">3</a>)  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Instance </td><td class="markdownTableBodyNone">Buffer  </td></tr>
</table>
<dl class="section note"><dt>Заметки</dt><dd><ul>
<li>Компонент Present должен завершать набор компонентов каждого объекта 3D сцены.</li>
<li>Указание значения <b>kind</b> не обязательно; если задан только Buffer.Index, будет создан компонент Present.Index, если заданы и Buffer.Index и Buffer.Instance - <a class="el" href="a43173.html">Present.Instance</a>.</li>
</ul>
</dd></dl>
<h3>Updater</h3>
<p>Компонент обновления объекта. Позволяет установить функциональный объект (функцию обратного вызова), связанную с конкретным объектом.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Параметры </th><th class="markdownTableHeadNone">Тип параметра </th><th class="markdownTableHeadNone">Описание параметра  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">function </td><td class="markdownTableBodyNone">std::function&lt;void(const float)&gt; </td><td class="markdownTableBodyNone">Функциональный объект, который будет вызываться при активации рендера компонента  </td></tr>
</table>
<dl class="section note"><dt>Заметки</dt><dd><ul>
<li>Переданному функциональному объекту при вызове будет передаваться время рендеринга текущего кадра (отсчет ведется с момента запуска программы) в секундах.</li>
<li>Гарантируется, что в рамках рендеринга одного кадра все updater'ы всех объектов получат одно и то же значение времени.</li>
<li>Компоненту можно установить новый функциональный объект в любой момент времени (это может делать даже сам вызванный функциональный объект во время работы, безо всяких ограничений).</li>
</ul>
</dd></dl>
<hr  />
<p>Если необходимо, чтобы updater объекта вызывался только тогда, когда рендерится сам объект (например, когда он находится в поле зрения камеры), то компонент updater'a можно добавить в список компонентов самого объекта и забыть о нем. Если же updater нужно вызывать независимо от того, рендерится объект в текущем кадре или нет, то необходимо компонент его updater'a поместить в отдельный игровой объект и вызывать его рендер индивидуально.</p>
<h3>Fog (deprecated)</h3>
<p>Компонент тумана.</p>
<dl class="deprecated"><dt><b><a class="el" href="a41445.html#_deprecated000003">Уст.:</a></b></dt><dd>Компонент устарел и будет удалены в следующей стабильной версии, вместо него следует использовать пользовательский константный буфер и явным образом задействовать его в шейдере.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">kind </th><th class="markdownTableHeadNone">Требуется Data (kind) </th><th class="markdownTableHeadNone">Параметры </th><th class="markdownTableHeadNone">Тип параметра </th><th class="markdownTableHeadNone">Описание параметра  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">- </td><td class="markdownTableBodyNone">Fog (<a class="el" href="a43172.html#Footnote">3</a>) </td><td class="markdownTableBodyNone">style </td><td class="markdownTableBodyNone">String_t </td><td class="markdownTableBodyNone">Тип тумана: linear (по умолчанию), exp, exp2  </td></tr>
</table>
<dl class="section note"><dt>Заметки</dt><dd><ul>
<li>Шейдерные реализации просто передают параметры шейдеру (константный буфер шейдера <b>FogData</b>) и их необходимо явно задействовать в оном.</li>
<li>В реализация со статическим конвеером камера при рендеринге отключает использование тумана.</li>
</ul>
</dd></dl>
<h3>Material (deprecated)</h3>
<p>Компонент материала (нужен для расчета освещения).</p>
<dl class="deprecated"><dt><b><a class="el" href="a41445.html#_deprecated000004">Уст.:</a></b></dt><dd>Компонент имеет смысл только для реализаций со статическим конвеером, шейдерные реализации должны использовать PBR-текстурирование.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Параметры </th><th class="markdownTableHeadNone">Тип параметра </th><th class="markdownTableHeadNone">Описание параметра  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">ambient </td><td class="markdownTableBodyNone">uint32_t </td><td class="markdownTableBodyNone">Цвет в формате ARGB (0xFF333333)  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">diffuse </td><td class="markdownTableBodyNone">uint32_t </td><td class="markdownTableBodyNone">Цвет в формате ARGB (0xFFCCCCCC)  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">specular </td><td class="markdownTableBodyNone">uint32_t </td><td class="markdownTableBodyNone">Цвет в формате ARGB (0xFF000000)  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">emission </td><td class="markdownTableBodyNone">uint32_t </td><td class="markdownTableBodyNone">Цвет в формате ARGB (0xFF000000)  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">shininess </td><td class="markdownTableBodyNone">int32_t </td><td class="markdownTableBodyNone">Значение в диапазоне 0...0x80  </td></tr>
</table>
<dl class="section note"><dt>Заметки</dt><dd><ul>
<li>Материал должен устанавливаться для каждого объекта 3D сцены, которому требуется расчет освещения.</li>
</ul>
</dd></dl>
<h3>Light (deprecated)</h3>
<p>Компонент источника света.</p>
<dl class="deprecated"><dt><b><a class="el" href="a41445.html#_deprecated000005">Уст.:</a></b></dt><dd>Компонент устарел и будет удален в следующей стабильной версии, вместо него использовать компонент Buffer.Constant с функцией обратного вызова, получающей Lights_t *.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">kind </th><th class="markdownTableHeadNone">Требуется Data (kind) </th><th class="markdownTableHeadNone">Параметры </th><th class="markdownTableHeadNone">Тип параметра </th><th class="markdownTableHeadNone">Описание параметра  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Ambient </td><td class="markdownTableBodyNone">- </td><td class="markdownTableBodyNone">color </td><td class="markdownTableBodyNone">uint32_t </td><td class="markdownTableBodyNone">Цвет (ambient) в формате ARGB (0xFF00FF00)  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Direction </td><td class="markdownTableBodyNone">Direction </td><td class="markdownTableBodyNone">color </td><td class="markdownTableBodyNone">uint32_t </td><td class="markdownTableBodyNone">Цвет (diffuse и specular) в формате ARGB (0xFF00FF00)  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Point </td><td class="markdownTableBodyNone">Position, Attenuation </td><td class="markdownTableBodyNone">color </td><td class="markdownTableBodyNone">uint32_t </td><td class="markdownTableBodyNone">Цвет (diffuse и specular) в формате ARGB (0xFF00FF00)  </td></tr>
</table>
<dl class="section note"><dt>Заметки</dt><dd><ul>
<li>Фоновых и направленных источников света может быть не более одного, точечных может быть несколько.</li>
<li>Пропущенные параметры устанавливаются в 0xFF000000.</li>
<li>Параметры компонента Data.Attenuation используются следующим образом: <br  />
 bright = color / (const + (linear + exponent * distance) * distance).</li>
<li>При удалении точечных источников света из 3D сцены следует учитывать, что источник света, не попадающий в поле зрения камеры тем не менее может освещать объекты, попадающие в поле зрения камеры.</li>
<li>Если используется рендеринг при помощи шейдеров (DirectX10/11), то информация об источниках света просто передается пиксельному шейдеру и необходимо самостоятельно задействовать эту информацию в шейдере (форматы передачи данных шейдерам см. <a class="el" href="a41449.html">Fx</a>); также для рендеринга сцены без источников света следует использовать пиксельный шейдер, который не использует информацию об источниках света.</li>
</ul>
</dd></dl>
<hr  />
<p>Логика использования источников света предполагает:</p><ul>
<li>Активация рендера камеры создает новую сцену, в которой по умолчанию источники света отсутствуют (поэтому, если - например - требуется отрисовать несколько объектов без использования освещения, следует выделить их в отдельную сцену со своей уникальной камерой).</li>
<li>Компоненты источников света могут располагаться в любом месте списка объектов при создании рендеров (при этом необходимо учитывать, что рендеры источников света добавляют информацию о себе в список источников света текущей сцены (другими словами - активной камеры), а при рендеринге текущего кадра используются источники света, установленные во время рендеринга предыдущего кадра).</li>
</ul>
<p>При использовании точечных источников света следует учитывать, что реализации, использующие статический конвеер (и с этим ничего нельзя сделать) реализуют расчет освещения по Гуро (вычисляются цвета вершин, промежуточные получаются путем интерполяции). Т.е. источник света рядом с большой поверхностью, заданной четырьмя вершинами (факел на стене) не даст реалистичного круглого пятна света - вместо этого будет получена однотонная слабо освещенная поверхность, т.к. вершины расположены далеко и (скорее всего) будут иметь черный цвет. В этом случае следует использовать карты освещения или написать собственный шейдер, реализующий другой метод расчета освещения.</p>
<p>Пример использования разных типов расчета освещения применительно к одной и той же плоскости, заданной четырьмя вершинами:</p>
<div class="image">
<img src="Lights.png" alt=""/>
</div>
<h3>Present (deprecated)</h3>
<p>Компонент отправки информации в конвеер рендеринга.</p>
<dl class="deprecated"><dt><b><a class="el" href="a41445.html#_deprecated000006">Уст.:</a></b></dt><dd>Компонент Present.Geometry устарел и будет удален в следующей стабильной версии, вместо него использовать компоненты Present.Index (или Present.Instance) и Transform.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">kind </th><th class="markdownTableHeadNone">Требуется Data (kind) </th><th class="markdownTableHeadNone">Параметры </th><th class="markdownTableHeadNone">Тип параметра </th><th class="markdownTableHeadNone">Описание параметра  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone" rowspan="3">Geometry </td><td class="markdownTableBodyNone" rowspan="2">Position/Rotation/Scale (<a class="el" href="a43172.html#Footnote">4</a>) </td><td class="markdownTableBodyNone" rowspan="3">variety </td><td class="markdownTableBodyNone" rowspan="3">String_t </td><td class="markdownTableBodyNone">Параметр отсутствует - динамический объект  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Static - статический объект  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Position (<a class="el" href="a43172.html#Footnote">4</a>) </td><td class="markdownTableBodyNone">Billboard - объект, всегда развернутый 'лицом' к камере  </td></tr>
</table>
<dl class="section note"><dt>Заметки</dt><dd><ul>
<li>Компонент Present должен завершать набор компонентов каждого объекта 3D сцены и должен иметь уникальный id для каждого конкретного объекта.</li>
<li>У статического объекта мировая матрица будет вычислена один раз при его создании и в дальнейшем изменить его положение/ориентацию/масштаб будет невозможно; динамический объект захватывает переданные ему компоненты Data, поэтому его положение/ориентацию/масштаб можно менять в каждом кадре изменяя значения параметров этих компонентов.</li>
<li>'Лицом' billboard'a считается плоскость Oxy при взгляде со стороны положительных значений вдоль оси z.</li>
</ul>
</dd></dl>
<h2>Сноски </h2>
<p><a class="anchor" id="Footnote"></a></p><ol type="1">
<li>Параметры этих компонентов могут изменяться во время работы программы (т.е. для изменения положения объекта в пространстве не нужно его пересоздавать, достаточно установить новые координаты комопоненту его положения), для изменения остальных (например замены 3D модели объекта) необходимо создать новый набор компонентов, удалить из 3D сцены старый и создать новый объект.</li>
<li><a class="el" href="a41954.html">Vertex::Polygon</a> создан специально для рендеринга элементов Gui и соответствует формату данных, получаемых от Rocket/RmlUi.</li>
<li>Параметры можно указывать непосредственно основному компоненту, без использования компонента Data.</li>
<li>Может быть несколько компонентов, что можно использовать для привязки (совместного движения) объектов друг к другу (в этом случае необходимо гарантировать, чтобы в качестве общего компонента использовался ОДИН И ТОТ ЖЕ объект, совпадения идентификаторов компонентов недостаточно!).</li>
</ol>
<h1>Общая концепция использования компонентов </h1>
<p>Основная идея работы с 3D объектами предполагает использование архитектуры программы на основе паттерна MVC.</p>
<h2>Модель </h2>
<ul>
<li>Загружает игровой мир как набор ячеек, каждая из которых ссылается на место хранения информации о содержащихся в ячейке объектах.</li>
<li>Содержит базу данных игровых объектов и функции, которые позволяют получать набор компонентов (для обновления и рендеринга) игрового объекта по его идентификатору.</li>
<li>Содержит игровую сцену(ы), которая включает идентификаторы камеры, а также источников света и объектов, находящихся рядом с камерой.</li>
<li>При перемещениях игрока добавляются приблизившиеся к камере и удаляются удалившиеся объекты (группами в ячейках).</li>
<li>На стадии обновления обновляются объекты игровой сцены (можно обновлять объекты постепенно удаляясь от камеры пока не выйдет заданное на обновление время).</li>
</ul>
<h2>Представление </h2>
<ul>
<li>Класс окна, которое создается между окнами Api и Gui.</li>
<li>Содержит, создает и удаляет объекты 3D сцены на основе информации, полученной от модели.</li>
<li>При построении/обновлении 3D сцены первой должна идти камера.</li>
<li>Изменение геометрии/материала производится удалением/добавлением игрового объекта.</li>
</ul>
<h2>Взаимодействие частей кода игры </h2>
<ul>
<li>Панель GUI с кнопками действий игрока (View) подписывается на события нажатия кнопок, при получении которых генерирует события действий игрока.</li>
<li>Игровой мир (Model) подписывается на события действий игрока:<ul>
<li>Обновляет состояние игрока и объектов игровой сцены.</li>
<li>В очередь создания объектов добавляются объекты, которые теперь попадают в зону действия камеры.</li>
<li>Из игровой сцены удаляются объекты, расположенные слишком далеко от камеры.</li>
</ul>
</li>
<li>3D сцена (View):<ul>
<li>По событию создания объекта запрашивает у модели набор компонентов объекта и создает его рендер.</li>
<li>По событию удаления объекта удаляет его рендер.</li>
<li>По событию отрисовки окна запрашивает у модели актуальынй набор игровых объектов и активирует их рендеры.</li>
</ul>
</li>
</ul>
<h1>Примеры использования компонентов </h1>
<p><a class="el" href="a43160.html">Отрисовка 2D объектов</a></p>
<p><a class="el" href="a43162.html">Отрисовка 3D объектов</a> </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="index.html">index</a></li><li class="navelem"><a class="el" href="a43168.html">Структура решения</a></li><li class="navelem"><a class="el" href="a43175.html">Covellite.Api</a></li>
    <li class="footer">Документация по Covellite++. Последние изменения: Чт 28 Май 2020 23:18:02. Создано системой
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.18 </li>
  </ul>
</div>
</body>
</html>
